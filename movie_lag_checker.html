<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</title>

  <style>
    :root{
      --panel: rgba(18, 26, 40, 0.86);
      --panel2: rgba(18, 26, 40, 0.65);
      --text: #e8eef7;
      --muted: rgba(232,238,247,.70);
      --line: rgba(88, 120, 170, 0.35);
      --accent: rgba(58,123,213,.95);
      --danger: rgba(255,107,107,.95);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    html, body{
      height: 100%;
      background: radial-gradient(1200px 800px at 20% 10%, #0e1a2f 0%, #05070d 60%);
      color: var(--text);
      margin: 0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif;
    }
    *{ box-sizing:border-box; }
    h1{ font-size:18px; margin:0 0 10px; }

    .wrap{ max-width:1120px; margin:0 auto; padding:14px; padding-bottom:40px; }
    .panel{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row + .row{ margin-top:10px; }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: var(--panel2);
    }
    .pill label{ font-size:12px; color:var(--muted); white-space:nowrap; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted{ color:var(--muted); font-size:12px; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.5; margin-top:8px; }

    button, input[type="file"]::file-selector-button{
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:hover{ background: rgba(18, 26, 40, 0.75); border-color: rgba(88,120,170,.55); }
    button:active{ transform: scale(0.99); }
    button.accent{ border-color: rgba(58,123,213,.75); background: rgba(58,123,213,.22); }
    button.danger{ border-color: rgba(255,107,107,.75); background: rgba(255,107,107,.18); }
    button.mini{ padding:8px 10px; font-size:13px; border-radius:12px; }
    button:disabled{ opacity:0.45; cursor:not-allowed; transform:none; }

    select, input[type="range"]{ accent-color: var(--accent); }
    select{
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 14px;
    }

    .video-shell{
      width:100%;
      border-radius:18px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .stage-wrap{
      display:flex;
      justify-content:center;
      align-items:center;
      width:100%;
      min-height:220px;
      padding:14px;
    }
    .stage{
      position:relative;
      max-width:100%;
      max-height:70vh;
      border-radius:14px;
      overflow:hidden;
      background:#000;
      touch-action:none;
    }
    #content{
      position:relative;
      display:inline-block;
      transform-origin:center center;
    }
    video{
      display:block;
      max-width:100%;
      max-height:70vh;
      background:#000;
    }

    .focus-rect{
      position:absolute;
      border:2px solid;
      border-radius:10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.10) inset;
      pointer-events:none;
      opacity:.70;
    }
    .focus-rect.active{ opacity:1.0; }
    .focus-a{ border-color: rgba(58,123,213,.95); }
    .focus-b{ border-color: rgba(255,107,107,.95); }
    .crosshair::before, .crosshair::after{
      content:"";
      position:absolute;
      background: rgba(232,238,247,.85);
      opacity:.65;
    }
    .crosshair::before{ left:50%; top:6px; width:2px; height:calc(100% - 12px); transform:translateX(-1px); border-radius:2px; }
    .crosshair::after{ top:50%; left:6px; height:2px; width:calc(100% - 12px); transform:translateY(-1px); border-radius:2px; }

    .bar{
      display:flex; align-items:center; gap:10px; padding:10px 12px;
      border-top:1px solid var(--line);
      background: rgba(18,26,40,.35);
    }
    .bar input[type="range"]{ width:100%; }

    .grid{ display:grid; grid-template-columns: 1fr; gap:12px; margin-top:10px; }
    .histRow{ display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; align-items:stretch; }
    .histCol{ flex:1; min-width:380px; }
    .list{
      max-height: min(70vh, 720px);
      min-height: 520px;
      overflow:auto;
      padding-right: 6px;
    }
    @media (max-width:540px){
      .histCol{ min-width:100%; }
      .list{ min-height:320px; max-height:55vh; }
      .bar{ flex-wrap:wrap; }
    }

    .item{
      border:1px solid var(--line);
      background: rgba(18,26,40,.35);
      border-radius:14px;
      padding:10px;
      margin-bottom:8px;
      cursor:pointer;
    }
    .item:hover{ border-color: rgba(88,120,170,.55); }
    .item .top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }

    .badge{
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      color: var(--muted);
      white-space:nowrap;
    }
    .badge.input{ border-color: rgba(58,123,213,.75); color: rgba(58,123,213,1); background: rgba(58,123,213,.10); }
    .badge.output{ border-color: rgba(255,107,107,.75); color: rgba(255,107,107,1); background: rgba(255,107,107,.08); }

    /* ---- magnifiers (2) */
    .mag{
      position:fixed;
      width:220px; /* overridden by magSize */
      background:#070a10;
      border:1px solid #223049;
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 8px 26px rgba(0,0,0,.35);
      z-index:9999;
      touch-action:none;
      display:flex;
      flex-direction:column;
    }
    .mag.mag-a.active{ border-color: rgba(58,123,213,.95); }
    .mag.mag-b.active{ border-color: rgba(255,107,107,.95); }

    .mag header{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      font-size:12px;
      opacity:.95;
      background:#0d1320;
      border-bottom:1px solid #223049;
      user-select:none;
      cursor: move;
      touch-action:none;
    }
    .magTitle{ font-weight:600; }
    .magBtns{ margin-left:auto; display:flex; gap:6px; align-items:center; }
    .mag header button{ padding:4px 8px; font-size:12px; border-radius:10px; }
    .mag canvas{
      display:block;
      width:100%;
      height:auto;
      aspect-ratio: 1 / 1;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h1>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</h1>

      <div class="row">
        <div class="pill">
          <label>動画</label>
          <input id="file" type="file" accept="video/*" />
        </div>

        <div class="pill">
          <label for="fps">参考FPS</label>
          <select id="fps">
            <option>24</option><option>30</option><option>60</option><option>120</option><option selected>240</option>
          </select>
        </div>
        <div class="pill">
          <label for="stepRate">コマ送り速度</label>
          <select id="stepRate">
            <option value="1" selected>1 コマ/秒</option>
            <option value="2">2 コマ/秒</option>
            <option value="3">3 コマ/秒</option>
            <option value="4">4 コマ/秒</option>
            <option value="5">5 コマ/秒</option>
            <option value="10">10 コマ/秒</option>
            <option value="15">15 コマ/秒</option>
          </select>
        </div>


        <div class="pill" title="iPhoneのスローモ動画が60fps相当のタイムラインとして扱われる場合、ここをONにすると結果を補正できます（Δms中央値から自動推定）">
          <label for="timeScaleOn">タイム補正</label>
          <input id="timeScaleOn" type="checkbox" checked />
          <span id="timeScaleLabel" class="mono">x1.000</span>
        </div>

        <div class="pill">
          <label for="zoom">表示ズーム</label>
          <input id="zoom" type="range" min="0.5" max="2.0" step="0.01" value="1.00" />
          <span id="zoomVal" class="mono">1.00x</span>
        </div>

        <button id="rotL" class="mini" title="左に90°回転">↺ 回転</button>
        <button id="rotR" class="mini" title="右に90°回転">↻ 回転</button>

        <div class="pill">
          <label for="magOn">拡大窓</label>
          <input id="magOn" type="checkbox" checked />
        </div>

        <div class="pill">
          <label for="magZoom">拡大倍率</label>
          <input id="magZoom" type="range" min="0.25" max="8" step="0.05" value="1.00" />
          <span id="magZoomVal" class="mono">1.0x</span>
        </div>

        <div class="pill">
          <label for="magSize">拡大範囲</label>
          <input id="magSize" type="range" min="80" max="360" step="2" value="220" />
          <span id="magSizeVal" class="mono">220px</span>
        </div>

        <div class="pill">
          <label>拡大位置（A/B）</label>
          <button id="pickA" class="mini accent" type="button">A:ボタン</button>
          <button id="pickB" class="mini" type="button">B:表示</button>
          <span id="pickHint" class="muted">→ 動画をタップ/ドラッグで A を移動</span>
        </div>
      </div>

      <div class="row">
        <div class="video-shell">
          <div class="stage-wrap">
            <div id="stage" class="stage">
              <div id="content">
                <video id="video" playsinline muted preload="auto"></video>
                <div id="focusRectA" class="focus-rect crosshair focus-a"></div>
                <div id="focusRectB" class="focus-rect crosshair focus-b"></div>
              </div>
            </div>
          </div>

          <div class="bar">
            <button id="toStart">⏮ 先頭</button>
            <button id="stepBack">◀ 1コマ戻る</button>
            <button id="stepPlayBack" class="accent">◀ コマ戻し（1コマ/秒）</button>
            <button id="stepPlay" class="accent">▶ コマ送り（1コマ/秒）</button>
            <button id="pauseBtn">⏸ 停止</button>
            <button id="stepFwd">1コマ進む ▶</button>
            <button id="toEnd">末尾 ⏭</button>

            <div class="pill" style="flex:1; min-width: 220px;">
              <label>シーク</label>
              <input id="seek" type="range" min="0" max="1" step="0.001" value="0" />
              <span class="mono" id="seekNow">0:00.000</span>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="pill">
          <label>表示中フレーム</label>
          <span class="mono">mediaTime:</span>
          <span id="mtNow" class="mono">—</span>
        </div>
        <div class="pill">
          <label>位置</label>
          <span class="mono">currentTime:</span>
          <span id="ctNow" class="mono">—</span>
        </div>
      </div>

      <div class="row">
        <button id="markInput" class="accent">入力を記録</button>
        <button id="markOutput" class="danger">表示反映を記録</button>
        <button id="clearCurrent">現在値クリア</button>
        <button id="prevMarker">← 前のマーカー</button>
        <button id="nextMarker">次のマーカー →</button>
        <button id="copyCurrent">現在の結果をコピー</button>
        <button id="resetVfr">VFR統計/補正リセット</button>
      </div>

      <div class="grid">
        <div class="panel" style="padding:12px;">
          <div class="row" style="justify-content: space-between; align-items:flex-start;">
            <div style="flex:1; min-width: 260px;">
              <div class="muted">現在の記録（最後に押した値が正）</div>
              <div id="currentSummary" class="mono" style="margin-top:6px; font-size: 14px; line-height:1.6;"></div>
              <div class="row" style="margin-top: 8px;">
                <div class="pill">
                  <label>VFR揺れ（コマ送り時Δms）</label>
                  <span id="vfrDisp" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>補正基準Δms</label>
                  <span id="vfrMedianDisp" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>推定fps</label>
                  <span id="vfrFpsDisp" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>補正係数</label>
                  <span id="timeScaleDisp" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>参考：1フレms</label>
                  <span id="refFrameMs" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>参考：差分フレ</label>
                  <span id="refFrames" class="mono">—</span>
                </div>
              </div>
            </div>

            <div style="flex:1; min-width: 260px; text-align:left;">
              <div class="muted">このアプリの前提</div>
              <div class="hint">
                iPhoneの高fps/スローモ動画は「タイムラインが60fps相当に解釈される」ことがあり、その場合 mediaTime/currentTime で測る差分が約4倍になることがあります。<br/>
                このページは <b>mediaTime（秒）で記録</b>し、差分は (display - input) * 1000 で算出します。<br/>
                さらに、コマ送りで観測した Δms の<b>中央値</b>から「実効fps」を推定し、参考FPS（プルダウン）に合わせて<b>補正係数</b>を自動推定できます（タイム補正ON）。<br/>
                ショートカット: ←/→=コマ送り　I=入力記録　O=反映記録　J/K=前/次マーカー　Space=コマ送りON/OFF
              </div>
            </div>
          </div>

          <div class="histRow">
            <div class="panel histCol" style="padding:10px;">
              <div class="muted">マーカー履歴（クリックでジャンプ）</div>
              <div id="markerList" class="list" style="margin-top:8px;"></div>
            </div>

            <div class="panel histCol" style="padding:10px;">
              <div class="muted">測定履歴（入力+反映が揃った瞬間に追加）</div>
              <div id="measureList" class="list" style="margin-top:8px;"></div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <!-- 拡大窓（2つ） -->
  <!-- ※初期位置はleft/topだけに統一（クリックでズレる原因を排除） -->
  <div id="magA" class="mag mag-a" style="display:none; left: 10px; top: 90px;">
    <header id="magHeaderA">
      <span class="magTitle">A: ボタン押下</span>
      <span id="magInfoA" class="mono">—</span>
      <div class="magBtns">
        <button id="magMarkInput" type="button" class="accent" title="入力を記録">入力</button>
      </div>
    </header>
    <canvas id="magCanvasA" width="400" height="400"></canvas>
  </div>

  <div id="magB" class="mag mag-b" style="display:none; left: 260px; top: 90px;">
    <header id="magHeaderB">
      <span class="magTitle">B: 画面表示</span>
      <span id="magInfoB" class="mono">—</span>
      <div class="magBtns">
        <button id="magMarkOutput" type="button" class="accent" title="表示反映を記録">反映</button>
      </div>
    </header>
    <canvas id="magCanvasB" width="400" height="400"></canvas>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // DOM
  const file = $("file");
  const video = $("video");
  const stage = $("stage");
  const content = $("content");

  const focusRectA = $("focusRectA");
  const focusRectB = $("focusRectB");

  const fpsSel = $("fps");
  const stepRate = $("stepRate");
  const timeScaleOn = $("timeScaleOn");
  const timeScaleLabel = $("timeScaleLabel");

  const zoom = $("zoom");
  const zoomVal = $("zoomVal");
  const rotL = $("rotL");
  const rotR = $("rotR");

  const magOn = $("magOn");
  const pickA = $("pickA");
  const pickB = $("pickB");
  const pickHint = $("pickHint");

  // Magnifiers
  const magA = $("magA");
  const magCanvasA = $("magCanvasA");
  const magCtxA = magCanvasA.getContext("2d");
  const magInfoA = $("magInfoA");
  const magHeaderA = $("magHeaderA");
  const magMarkInput = $("magMarkInput");

  const magB = $("magB");
  const magCanvasB = $("magCanvasB");
  const magCtxB = magCanvasB.getContext("2d");
  const magInfoB = $("magInfoB");
  const magHeaderB = $("magHeaderB");
  const magMarkOutput = $("magMarkOutput");

  const magZoom = $("magZoom");
  const magZoomVal = $("magZoomVal");
  const magSize = $("magSize");
  const magSizeVal = $("magSizeVal");

  // Controls
  const seek = $("seek");
  const seekNow = $("seekNow");
  const toStart = $("toStart");
  const toEnd = $("toEnd");
  const stepBack = $("stepBack");
  const stepFwd = $("stepFwd");
  const stepPlay = $("stepPlay");
  const stepPlayBack = $("stepPlayBack");
  const pauseBtn = $("pauseBtn");

  const mtNow = $("mtNow");
  const ctNow = $("ctNow");

  const markInput = $("markInput");
  const markOutput = $("markOutput");
  const clearCurrent = $("clearCurrent");
  const prevMarker = $("prevMarker");
  const nextMarker = $("nextMarker");
  const copyCurrent = $("copyCurrent");
  const resetVfr = $("resetVfr");

  const currentSummary = $("currentSummary");
  const vfrDisp = $("vfrDisp");
  const vfrMedianDisp = $("vfrMedianDisp");
  const vfrFpsDisp = $("vfrFpsDisp");
  const timeScaleDisp = $("timeScaleDisp");

  const refFrameMs = $("refFrameMs");
  const refFrames = $("refFrames");

  const markerList = $("markerList");
  const measureList = $("measureList");

  // State
  let rotation = 0;
  let viewZoom = 1.00;
  let stageW = 0;
  let stageH = 0;

  let rvfcId = null;

  let curMediaTime = null; // seconds (from mediaTime)
  let curCurrentTime = null;

  let stepLoopToken = 0;
  let stepLoopRunning = false;
  let stepDir = +1; // +1: forward, -1: backward
  let busy = false;

  let focusA = { x: 0, y: 0, size: 220 };
  let focusB = { x: 0, y: 0, size: 220 };

  let activePick = "A";

  let inputMark = null;
  let outputMark = null;

  let markers = [];
  let markerSel = -1;
  let measures = [];

  // VFR stats (step-only)
  let vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };

  // TimeScale estimation from step Δms
  let deltaMsBuf = [];
  let vfrMedian = NaN;
  let vfrEffFps = NaN;
  let timeScale = 1.0;

  // Utils
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const getFpsRef = () => Number(fpsSel.value || 240);

  const getStepRate = () => {
    const v = Number(stepRate?.value || 1);
    return (Number.isFinite(v) && v > 0) ? v : 1;
  };

  function fmtTime(sec){
    if(sec == null || !Number.isFinite(sec)) return "—";
    sec = Math.max(0, sec);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec - Math.floor(sec)) * 1000);
    return `${m}:${String(s).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
  }

  function safeUUID(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function medianOf(arr){
    if(!arr || arr.length === 0) return NaN;
    const a = arr.slice().sort((x,y)=>x-y);
    const m = Math.floor(a.length/2);
    return (a.length % 2) ? a[m] : (a[m-1] + a[m]) / 2;
  }
  function percentileOf(arr, p){
    if(!arr || arr.length === 0) return NaN;
    const a = arr.slice().sort((x,y)=>x-y);
    const clamped = Math.max(0, Math.min(1, p));
    const pos = (a.length - 1) * clamped;
    const lo = Math.floor(pos);
    const hi = Math.ceil(pos);
    if(lo === hi) return a[lo];
    const t = pos - lo;
    return a[lo] * (1 - t) + a[hi] * t;
  }

  function snapEffFps(effFpsRaw, fpsRef){
    // iPhoneスローモ等の「よくある段階」にスナップして、コマ飛びで中央値がズレても補正が暴れないようにする
    const candidates = [];
    const divs = [1,2,3,4,5,6,8,10,12,15,16];
    for(const d of divs){
      candidates.push(fpsRef / d);
    }
    // 保険として一般的な値も追加
    [240,120,60,30,24].forEach(v => candidates.push(v));

    const uniq = Array.from(new Set(candidates.filter(v => Number.isFinite(v) && v > 1))).sort((a,b)=>a-b);
    let best = { fps: effFpsRaw, rel: Infinity };
    for(const c of uniq){
      const rel = Math.abs(c - effFpsRaw) / c;
      if(rel < best.rel) best = { fps: c, rel };
    }
    // 12%以内ならスナップ採用（外れ値はそのまま）
    if(best.rel <= 0.12) return best.fps;
    return effFpsRaw;
  }



  function recomputeTimeScale(){
    // ★ポイント:
    //  - コマ送り（seek）では、ブラウザ都合で 1回の操作で2コマ/3コマ飛ぶことがある
    //  - その場合「中央値Δms」を基準にすると補正係数が 0.5 / 0.125 のように狂いやすい
    //  - そこで「低位（p10）のΔms」を “1コマ相当の基準” とみなし、補正はそれで推定する
    const recent = deltaMsBuf.slice(-120);
    const med = medianOf(recent);

    // 低位パーセンタイル（1コマの最小刻みを拾う狙い）
    const base = percentileOf(recent, 0.10);

    vfrMedian = med;

    // 推定fpsは「補正基準Δms」から算出（コマ飛び耐性）
    const effRaw = (Number.isFinite(base) && base > 0) ? (1000 / base) : NaN;
    vfrEffFps = Number.isFinite(effRaw) ? snapEffFps(effRaw, getFpsRef()) : NaN;

    // 補正係数 = (idealFrameMs / baseDeltaMs) = (effFps / refFps)
    let scale = 1.0;
    if(deltaMsBuf.length >= 8 && Number.isFinite(vfrEffFps) && vfrEffFps > 0){
      scale = vfrEffFps / getFpsRef();
      if(!Number.isFinite(scale) || scale <= 0) scale = 1.0;
      if(scale < 0.02 || scale > 20) scale = 1.0;
    }
    timeScale = scale;
    updateTimeScaleUI();
  }

  function observeStepDeltaMs(dtMs){
    if(!Number.isFinite(dtMs) || dtMs <= 0) return;
    if(dtMs > 250) return; // ignore huge jumps

    vfr.min = Math.min(vfr.min, dtMs);
    vfr.max = Math.max(vfr.max, dtMs);
    vfr.sum += dtMs;
    vfr.n += 1;

    deltaMsBuf.push(dtMs);
    if(deltaMsBuf.length > 240) deltaMsBuf.shift();
    recomputeTimeScale();
  }

  function getScaleUsed(){
    return timeScaleOn.checked ? timeScale : 1.0;
  }

  function updateTimeScaleUI(){
    timeScaleLabel.textContent = `x${getScaleUsed().toFixed(3)}`;
  }

  function enableControls(on){
    const btns = [
      toStart,toEnd,stepBack,stepFwd,stepPlayBack,stepPlay,pauseBtn,seek,stepRate,
      markInput,markOutput,clearCurrent,prevMarker,nextMarker,copyCurrent,resetVfr
    ];
    btns.forEach(b => b.disabled = !on);
  }

  function updateStageTransform(){
    viewZoom = Number(zoom.value);
    zoomVal.textContent = `${viewZoom.toFixed(2)}x`;
    content.style.transformOrigin = "center center";
    content.style.transform = `rotate(${rotation}deg) scale(${viewZoom})`;
  }

  function updateStageSize(){
    stageW = content.clientWidth || video.clientWidth || stage.clientWidth || 0;
    stageH = content.clientHeight || video.clientHeight || stage.clientHeight || 0;
  }

  function stageToVideoMatrix(){
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if(!vw || !vh || !stageW || !stageH) return null;
    return { sx: vw / stageW, sy: vh / stageH };
  }

  function clientToStageXY(clientX, clientY){
    const r = stage.getBoundingClientRect();
    const x = clientX - r.left;
    const y = clientY - r.top;

    const cx = r.width / 2;
    const cy = r.height / 2;

    let dx = x - cx;
    let dy = y - cy;

    dx /= viewZoom;
    dy /= viewZoom;

    const rad = (-rotation) * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    const ux = dx*cos - dy*sin;
    const uy = dx*sin + dy*cos;

    return { x: ux + stageW/2, y: uy + stageH/2 };
  }

  function stageXYToVideoXY(stageX, stageY){
    const M = stageToVideoMatrix();
    if(!M) return null;
    return { x: stageX * M.sx, y: stageY * M.sy, sx: M.sx, sy: M.sy };
  }

  function applyFocusRect(el, f){
    f.size = Number(magSize.value);
    el.style.width = `${f.size}px`;
    el.style.height = `${f.size}px`;
    el.style.left = `${f.x - f.size/2}px`;
    el.style.top  = `${f.y - f.size/2}px`;
  }

  function updateActivePickUI(){
    const isA = activePick === "A";
    pickA.classList.toggle("accent", isA);
    pickB.classList.toggle("accent", !isA);

    focusRectA.classList.toggle("active", isA);
    focusRectB.classList.toggle("active", !isA);

    magA.classList.toggle("active", isA);
    magB.classList.toggle("active", !isA);
  }

  function updateFocusRects(){
    applyFocusRect(focusRectA, focusA);
    applyFocusRect(focusRectB, focusB);
    updateActivePickUI();
  }

  function updateSeekMax(){
    const d = video.duration;
    if(Number.isFinite(d) && d > 0){
      seek.max = d;
      seek.step = 0.001;
    }else{
      seek.max = 1;
    }
  }

  function updateSeekNow(){
    const t = video.currentTime || 0;
    seek.value = t;
    seekNow.textContent = fmtTime(t);
  }

  function updateNowLabels(){
    mtNow.textContent = fmtTime(curMediaTime);
    ctNow.textContent = fmtTime(curCurrentTime);
  }

  function updateVfrDisp(){
    if(vfr.n <= 0 || !Number.isFinite(vfr.min) || !Number.isFinite(vfr.max)){
      vfrDisp.textContent = "—";
    }else{
      const avg = vfr.sum / vfr.n;
      vfrDisp.textContent = `min ${vfr.min.toFixed(2)} / max ${vfr.max.toFixed(2)} / avg ${avg.toFixed(2)} ms (n=${vfr.n})`;
    }

    if(Number.isFinite(vfrEffFps) && vfr.n >= 8){
      const baseMs = 1000 / vfrEffFps;
      vfrMedianDisp.textContent = `${baseMs.toFixed(2)} ms`;
      vfrFpsDisp.textContent = `${vfrEffFps.toFixed(2)} fps`;
    }else if(vfr.n > 0){
      vfrMedianDisp.textContent = "学習中";
      vfrFpsDisp.textContent = "学習中";
    }else{
      vfrMedianDisp.textContent = "—";
      vfrFpsDisp.textContent = "—";
    }

    const scaleTxt = (vfr.n >= 6 && Number.isFinite(vfrMedian)) ? `x${timeScale.toFixed(3)}` : "学習中";
    timeScaleDisp.textContent = `${scaleTxt}（${timeScaleOn.checked ? "ON" : "OFF"}）`;
    updateTimeScaleUI();

    const fps = getFpsRef();
    const ms = 1000 / fps;
    refFrameMs.textContent = `${ms.toFixed(3)} ms`;

    if(inputMark && outputMark){
      const rawDelta = (outputMark.t - inputMark.t) * 1000;
      const usedDelta = rawDelta * getScaleUsed();
      refFrames.textContent = `${(usedDelta/ms).toFixed(2)} f`;
    }else{
      refFrames.textContent = "—";
    }
  }

  function updateCurrentSummary(){
    let html = "";
    if(!inputMark) html += `入力: <b>未記録</b><br/>`;
    else html += `入力: <b>${fmtTime(inputMark.t)}</b><br/>`;

    if(!outputMark) html += `反映: <b>未記録</b><br/>`;
    else html += `反映: <b>${fmtTime(outputMark.t)}</b><br/>`;

    if(inputMark && outputMark){
      const rawDeltaMs = (outputMark.t - inputMark.t) * 1000;
      const scaleUsed = getScaleUsed();
      const corrDeltaMs = rawDeltaMs * scaleUsed;

      const haveScale = (vfr.n >= 6 && Number.isFinite(vfrMedian));
      const scaleDiff = Math.abs(scaleUsed - 1.0);

      if(timeScaleOn.checked && haveScale && scaleDiff > 0.02){
        html += `差分(補正 x${scaleUsed.toFixed(3)}): <b>${corrDeltaMs.toFixed(2)} ms</b><br/>`;
        html += `差分(raw): <span class="muted">${rawDeltaMs.toFixed(2)} ms</span>（FPSは参考）<br/>`;
      }else if(timeScaleOn.checked){
        html += `差分: <b>${corrDeltaMs.toFixed(2)} ms</b>（補正ON x${scaleUsed.toFixed(3)} / FPSは参考）<br/>`;
      }else{
        html += `差分: <b>${rawDeltaMs.toFixed(2)} ms</b>（補正OFF / FPSは参考）<br/>`;
      }
    }else{
      html += `差分: <b>—</b><br/>`;
    }
    currentSummary.innerHTML = html;
    updateVfrDisp();
  }

  function renderMarkers(){
    markerList.innerHTML = "";
    if(!markers.length){
      markerList.innerHTML = `<div class="muted">まだマーカーがありません</div>`;
      return;
    }
    markers.slice().reverse().forEach((m, idxRev) => {
      const idx = markers.length - 1 - idxRev;
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge ${m.kind}">${m.kind === "input" ? "入力" : "反映"}</span>
          <span class="mono">${fmtTime(m.t)}</span>
        </div>
        <div class="muted">#${idx+1} / ${new Date(m.createdAt).toLocaleString()}</div>
      `;
      el.addEventListener("click", async () => {
        stopStepPlay();
        markerSel = idx;
        await seekTo(m.t);
      });
      markerList.appendChild(el);
    });
  }

  function renderMeasures(){
    measureList.innerHTML = "";
    if(!measures.length){
      measureList.innerHTML = `<div class="muted">まだ測定履歴がありません</div>`;
      return;
    }
    measures.slice().reverse().forEach((m) => {
      const main = m.correctedDeltaMs;
      const raw = m.rawDeltaMs;
      const scaleTxt = (m.scaleUsed != null) ? `x${m.scaleUsed.toFixed(3)}` : "—";
      const mode = (m.usedCorrection) ? "補正" : "raw";
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge">Δ</span>
          <span class="mono"><b>${main.toFixed(2)} ms</b> <span class="muted">(${mode})</span></span>
        </div>
        <div class="muted mono">raw ${raw.toFixed(2)} ms / scale ${scaleTxt} / refFPS ${m.fpsRef}</div>
        <div class="muted mono">input ${fmtTime(m.inputT)} / output ${fmtTime(m.outputT)}</div>
        <div class="muted">${new Date(m.createdAt).toLocaleString()}</div>
      `;
      measureList.appendChild(el);
    });
  }

  function pushMarker(kind, t){
    markers.push({ id: safeUUID(), kind, t, createdAt: Date.now() });
    renderMarkers();
  }

  function pushMeasure(inputT, outputT){
    const rawDeltaMs = (outputT - inputT) * 1000;
    const usedCorrection = timeScaleOn.checked;
    const scaleUsed = getScaleUsed();
    const correctedDeltaMs = rawDeltaMs * scaleUsed;

    measures.push({
      id: safeUUID(),
      inputT, outputT,
      rawDeltaMs,
      correctedDeltaMs,
      usedCorrection,
      scaleUsed,
      fpsRef: getFpsRef(),
      createdAt: Date.now()
    });
    renderMeasures();
  }

  // ---- rvfc / frame waiting
  let frameSeq = 0;
  let frameWaiters = [];

  function waitFrameAfter(seq, timeoutMs = 800){
    return new Promise((resolve) => {
      const waiter = { minSeq: seq + 1, resolve: null, timer: null };
      waiter.resolve = (ok) => {
        if(waiter.timer) clearTimeout(waiter.timer);
        resolve(ok);
      };
      waiter.timer = setTimeout(() => waiter.resolve(false), timeoutMs);
      frameWaiters.push(waiter);
    });
  }

  function onFrame(now, meta){
    frameSeq++;

    curMediaTime = (meta && Number.isFinite(meta.mediaTime)) ? meta.mediaTime : null;
    curCurrentTime = video.currentTime;

    updateNowLabels();
    updateSeekNow();
    updateCurrentSummary();
    drawMagnifiers();

    if(frameWaiters.length){
      const remain = [];
      for(const w of frameWaiters){
        if(frameSeq >= w.minSeq) w.resolve(true);
        else remain.push(w);
      }
      frameWaiters = remain;
    }

    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  function startRvfc(){
    if(rvfcId != null) return;

    if(typeof video.requestVideoFrameCallback !== "function"){
      const tick = () => {
        curCurrentTime = video.currentTime;
        curMediaTime = video.currentTime;
        updateNowLabels();
        updateSeekNow();
        updateCurrentSummary();
        drawMagnifiers();
        rvfcId = requestAnimationFrame(tick);
      };
      rvfcId = requestAnimationFrame(tick);
      return;
    }

    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  async function seekTo(t){
    const d = Number.isFinite(video.duration) ? video.duration : 0;
    t = clamp(t, 0, d);

    const beforeSeq = frameSeq;

    await new Promise(resolve => {
      const onSeeked = () => resolve();
      video.addEventListener("seeked", onSeeked, { once:true });
      if(typeof video.fastSeek === "function") video.fastSeek(t);
      else video.currentTime = t;
    });

    await waitFrameAfter(beforeSeq, 800);
  }

  // ---- step play
  function updateStepPlayLabel(){
    const r = getStepRate();
    const fOn = (stepLoopRunning && stepDir === +1);
    const bOn = (stepLoopRunning && stepDir === -1);

    stepPlay.textContent = fOn ? `⏱ ▶ コマ送り（${r}コマ/秒）ON` : `▶ コマ送り（${r}コマ/秒）`;
    stepPlayBack.textContent = bOn ? `⏱ ◀ コマ戻し（${r}コマ/秒）ON` : `◀ コマ戻し（${r}コマ/秒）`;
  }

  function stopStepPlay(){
    // 非同期ループを止める
    stepLoopToken++;
    stepLoopRunning = false;
    updateStepPlayLabel();
  }

  function sleep(ms){
    return new Promise(r => setTimeout(r, ms));
  }

  async function runStepLoop(localToken){
    stepLoopRunning = true;
    updateStepPlayLabel();

    while(stepLoopToken === localToken){
      video.pause();

      const r = getStepRate();
      const interval = Math.max(66, Math.round(1000 / r)); // 最低66ms（≈15fps）で安定させる
      const t0 = performance.now();

      // 1ステップが終わるのを待ってから次へ（重なり防止）
      await stepAdjacent(stepDir, true);

      const elapsed = performance.now() - t0;
      const wait = Math.max(0, interval - elapsed);

      if(wait > 0) await sleep(wait);
      else await sleep(0);
    }
  }

  function startStepPlay(dir){
    stepDir = dir;
    video.pause();

    const token = ++stepLoopToken;

    if(stepLoopRunning){
      updateStepPlayLabel();
      return;
    }
    runStepLoop(token);
  }

  async function stepAdjacent(direction, fromAuto = false){
    if(busy) return;
    busy = true;

    try{
      if(!fromAuto) stopStepPlay();
      video.pause();

      const startMT = (curMediaTime ?? video.currentTime);
      const startCT = video.currentTime;

      const d = Number.isFinite(video.duration) ? video.duration : 0;
      if(!d) return;

      let delta = (1 / getFpsRef()) * 0.6;
      let changed = false;

      for(let i=0; i<18; i++){
        const target = clamp(startCT + direction * delta, 0, d);
        await seekTo(target);

        const mt = (curMediaTime ?? video.currentTime);

        if(Number.isFinite(mt) && Math.abs(mt - startMT) > 1e-9){
          changed = true;
          observeStepDeltaMs(Math.abs((mt - startMT) * 1000));
          break;
        }
        delta *= 1.7;
      }

      if(!changed){
        const fallback = clamp(startCT + direction * 0.05, 0, d);
        await seekTo(fallback);
      }
    } finally {
      busy = false;
    }
  }

  // ---- Magnifier window positioning (drag only)
  const DRAG_THRESHOLD_PX = 4;

  function clampMagToViewport(el){
    const r = el.getBoundingClientRect();
    const pad = 6;
    let x = r.left, y = r.top;
    x = clamp(x, pad, window.innerWidth - r.width - pad);
    y = clamp(y, pad, window.innerHeight - r.height - pad);
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function saveMagPos(key, el){
    try{
      const r = el.getBoundingClientRect();
      localStorage.setItem(key, JSON.stringify({ x:r.left, y:r.top }));
    }catch{}
  }

  function restoreMagPos(key, el){
    try{
      const v = localStorage.getItem(key);
      if(!v) return false;
      const p = JSON.parse(v);
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) return false;
      el.style.left = `${p.x}px`;
      el.style.top  = `${p.y}px`;
      clampMagToViewport(el);
      return true;
    }catch{
      return false;
    }
  }

  function ensureDefaultMagPos(){
    const pad = 10;
    const top = Math.round(Math.max(pad, window.innerHeight * 0.12));

    if(!restoreMagPos("magA_pos", magA)){
      magA.style.left = `${pad}px`;
      magA.style.top  = `${top}px`;
      clampMagToViewport(magA);
      saveMagPos("magA_pos", magA);
    }

    if(!restoreMagPos("magB_pos", magB)){
      const rb = magB.getBoundingClientRect();
      magB.style.left = `${Math.max(pad, window.innerWidth - rb.width - pad)}px`;
      magB.style.top  = `${top}px`;
      clampMagToViewport(magB);
      saveMagPos("magB_pos", magB);
    }
  }

  function makeMagDraggable(el, headerEl, key){
    let armed = false;
    let dragging = false;
    let pointerId = null;
    let start = null;

    const ignoreIfButton = (e) => !!e.target.closest("button");

    headerEl.addEventListener("pointerdown", (e) => {
      if(el.style.display === "none") return;
      if(ignoreIfButton(e)) return;

      armed = true;
      dragging = false;
      pointerId = e.pointerId;

      const r = el.getBoundingClientRect();
      start = { px: e.clientX, py: e.clientY, left: r.left, top: r.top };

      headerEl.setPointerCapture(pointerId);
      e.preventDefault();
    });

    headerEl.addEventListener("pointermove", (e) => {
      if(!armed || e.pointerId !== pointerId || !start) return;

      const dx = e.clientX - start.px;
      const dy = e.clientY - start.py;

      if(!dragging){
        if(Math.hypot(dx, dy) < DRAG_THRESHOLD_PX) return;
        dragging = true;
      }

      el.style.left = `${start.left + dx}px`;
      el.style.top  = `${start.top + dy}px`;
      clampMagToViewport(el);
      e.preventDefault();
    });

    const end = (e) => {
      if(!armed || e.pointerId !== pointerId) return;
      armed = false;

      try{ headerEl.releasePointerCapture(pointerId); }catch{}

      if(dragging){
        saveMagPos(key, el);
      }

      dragging = false;
      pointerId = null;
      start = null;
      e.preventDefault();
    };

    headerEl.addEventListener("pointerup", end);
    headerEl.addEventListener("pointercancel", end);
  }

  function updateMagUI(){
    magZoomVal.textContent = `${Number(magZoom.value).toFixed(1)}x`;
    magSizeVal.textContent = `${Number(magSize.value)}px`;

    const on = magOn.checked;
    const hasVideo = !!video.videoWidth && !!video.videoHeight && !!stageW && !!stageH;
    const visible = on && hasVideo;

    magA.style.display = visible ? "" : "none";
    magB.style.display = visible ? "" : "none";
    focusRectA.style.display = visible ? "" : "none";
    focusRectB.style.display = visible ? "" : "none";

    const win = Number(magSize.value);
    magA.style.width = `${win}px`;
    magB.style.width = `${win}px`;

    const dpr = window.devicePixelRatio || 1;
    const px = Math.max(64, Math.round(win * dpr));
    magCanvasA.width = px; magCanvasA.height = px;
    magCanvasB.width = px; magCanvasB.height = px;

    if(visible){
      clampMagToViewport(magA);
      clampMagToViewport(magB);
    }

    updateFocusRects();
  }

  function drawMagnifierOne(which, f, magEl, canvas, ctx, infoEl){
    if(!magOn.checked) return;
    if(magEl.style.display === "none") return;
    if(!video.videoWidth || !video.videoHeight || !stageW || !stageH) return;

    const vpos = stageXYToVideoXY(f.x, f.y);
    if(!vpos) return;

    const mz = Number(magZoom.value);
    const outW = canvas.width;
    const outH = canvas.height;

    const cropW = (f.size * vpos.sx) / mz;
    const cropH = (f.size * vpos.sy) / mz;

    const sx = clamp(vpos.x - cropW/2, 0, video.videoWidth - cropW);
    const sy = clamp(vpos.y - cropH/2, 0, video.videoHeight - cropH);

    ctx.clearRect(0,0,outW,outH);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, outW, outH);

    ctx.strokeStyle = (which === "A") ? "rgba(58,123,213,.95)" : "rgba(255,107,107,.95)";
    ctx.lineWidth = Math.max(2, Math.round(outW * 0.008));
    ctx.strokeRect(6,6,outW-12,outH-12);

    ctx.strokeStyle = "rgba(232,238,247,.85)";
    ctx.lineWidth = Math.max(1, Math.round(outW * 0.005));
    ctx.beginPath();
    ctx.moveTo(outW/2, 10); ctx.lineTo(outW/2, outH-10);
    ctx.moveTo(10, outH/2); ctx.lineTo(outW-10, outH/2);
    ctx.stroke();

    infoEl.textContent = `mt ${fmtTime(curMediaTime)} / x${mz.toFixed(2)}`;
  }

  function drawMagnifiers(){
    if(!magOn.checked) return;
    drawMagnifierOne("A", focusA, magA, magCanvasA, magCtxA, magInfoA);
    drawMagnifierOne("B", focusB, magB, magCanvasB, magCtxB, magInfoB);
  }

  // ---- Events
  fpsSel.addEventListener("change", () => { recomputeTimeScale(); updateCurrentSummary(); });
  stepRate.addEventListener("change", () => {
    // ループは毎回getStepRate()を見るので再起動不要
    updateStepPlayLabel();
  });
  timeScaleOn.addEventListener("change", () => { updateTimeScaleUI(); updateCurrentSummary(); renderMeasures(); });

  zoom.addEventListener("input", () => updateStageTransform());
  rotL.addEventListener("click", () => { rotation = (rotation - 90) % 360; updateStageTransform(); });
  rotR.addEventListener("click", () => { rotation = (rotation + 90) % 360; updateStageTransform(); });

  magOn.addEventListener("change", () => updateMagUI());
  magZoom.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });
  magSize.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });

  pickA.addEventListener("click", () => {
    activePick = "A";
    updateActivePickUI();
    pickHint.textContent = "→ 動画をタップ/ドラッグで A を移動";
  });
  pickB.addEventListener("click", () => {
    activePick = "B";
    updateActivePickUI();
    pickHint.textContent = "→ 動画をタップ/ドラッグで B を移動";
  });

  magMarkInput.addEventListener("click", () => markInput.click());
  magMarkOutput.addEventListener("click", () => markOutput.click());

  toStart.addEventListener("click", async () => { stopStepPlay(); await seekTo(0); });
  toEnd.addEventListener("click", async () => { stopStepPlay(); await seekTo(video.duration || 0); });

  stepBack.addEventListener("click", async () => { await stepAdjacent(-1); });
  stepFwd.addEventListener("click", async () => { await stepAdjacent(+1); });

  pauseBtn.addEventListener("click", () => { stopStepPlay(); video.pause(); });

  stepPlay.addEventListener("click", () => {
    // 同じ方向ならトグル、逆方向なら切替
    if(stepLoopRunning && stepDir === +1){
      stopStepPlay();
      return;
    }
    startStepPlay(+1);
  });

  stepPlayBack.addEventListener("click", () => {
    if(stepLoopRunning && stepDir === -1){
      stopStepPlay();
      return;
    }
    startStepPlay(-1);
  });

  seek.addEventListener("input", async () => {
    stopStepPlay();
    await seekTo(Number(seek.value));
  });

  markInput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    inputMark = { t: curMediaTime, at: new Date(), kind:"input" };
    pushMarker("input", inputMark.t);
    updateCurrentSummary();
  });

  markOutput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    outputMark = { t: curMediaTime, at: new Date(), kind:"output" };
    pushMarker("output", outputMark.t);

    if(inputMark){
      pushMeasure(inputMark.t, outputMark.t);
    }
    updateCurrentSummary();
  });

  clearCurrent.addEventListener("click", () => {
    inputMark = null;
    outputMark = null;
    updateCurrentSummary();
  });

  prevMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel <= 0) ? (markers.length - 1) : (markerSel - 1);
    await seekTo(markers[markerSel].t);
  });

  nextMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel >= markers.length - 1) ? 0 : (markerSel + 1);
    await seekTo(markers[markerSel].t);
  });

  copyCurrent.addEventListener("click", async () => {
    const inT = inputMark ? inputMark.t : null;
    const outT = outputMark ? outputMark.t : null;

    let rawDeltaMs = null;
    let corrDeltaMs = null;
    let scaleUsed = null;

    if(inT != null && outT != null){
      rawDeltaMs = (outT - inT) * 1000;
      scaleUsed = getScaleUsed();
      corrDeltaMs = rawDeltaMs * scaleUsed;
    }

    const text =
`inputTime(mediaTime): ${inT != null ? fmtTime(inT) : "—"}
displayTime(mediaTime): ${outT != null ? fmtTime(outT) : "—"}
deltaMs(raw): ${rawDeltaMs != null ? rawDeltaMs.toFixed(2) : "—"} ms
deltaMs(shown): ${corrDeltaMs != null ? corrDeltaMs.toFixed(2) : "—"} ms
timeScale: ${scaleUsed != null ? "x"+scaleUsed.toFixed(3) : "—"} (${timeScaleOn.checked ? "ON" : "OFF"})
vfrBase: ${Number.isFinite(vfrMedian) ? vfrMedian.toFixed(2)+" ms" : "—"} / estFps: ${Number.isFinite(vfrEffFps) ? vfrEffFps.toFixed(2) : "—"} fps
refFPS: ${getFpsRef()}`;

    try{
      await navigator.clipboard.writeText(text);
    }catch{
      alert(text);
    }
  });

  resetVfr.addEventListener("click", () => {
    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    deltaMsBuf = [];
    vfrMedian = NaN;
    vfrEffFps = NaN;
    timeScale = 1.0;
    updateVfrDisp();
    updateCurrentSummary();
  });

  // File load
  file.addEventListener("change", async () => {
    stopStepPlay();

    inputMark = null;
    outputMark = null;
    markers = [];
    measures = [];
    markerSel = -1;

    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    deltaMsBuf = [];
    vfrMedian = NaN;
    vfrEffFps = NaN;
    timeScale = 1.0;

    renderMarkers();
    renderMeasures();
    updateVfrDisp();
    updateCurrentSummary();

    const f = file.files?.[0];
    if(!f) return;

    if(video.src && video.src.startsWith("blob:")){
      try{ URL.revokeObjectURL(video.src); }catch{}
    }

    const url = URL.createObjectURL(f);

    video.src = url;
    video.preload = "auto";
    video.muted = true;
    video.playsInline = true;
    video.load();

    try{
      await video.play();
      video.pause();
      video.currentTime = 0;
    }catch(e){
      console.log("prime play failed:", e);
    }
  });

  video.addEventListener("error", () => {
    const err = video.error;
    alert(`動画の読み込みに失敗しました（error code: ${err?.code ?? "?"}）\n別形式（H.264 mp4等）に変換すると再生できることがあります。`);
  });

  video.addEventListener("loadedmetadata", () => {
    enableControls(true);
    updateSeekMax();

    const ro = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        updateStageSize();

        if((focusA.x === 0 && focusA.y === 0) && (focusB.x === 0 && focusB.y === 0)){
          focusA.x = stageW * 0.35;
          focusA.y = stageH * 0.55;
          focusB.x = stageW * 0.65;
          focusB.y = stageH * 0.45;
        }
        updateMagUI();
        ensureDefaultMagPos();
        drawMagnifiers();
      });
    });
    ro.observe(content);

    updateStageSize();
    updateStageTransform();
    updateMagUI();

    // drag init
    makeMagDraggable(magA, magHeaderA, "magA_pos");
    makeMagDraggable(magB, magHeaderB, "magB_pos");

    ensureDefaultMagPos();

    startRvfc();
    updateVfrDisp();
  });

  window.addEventListener("resize", () => {
    if(magA.style.display !== "none"){
      clampMagToViewport(magA);
      clampMagToViewport(magB);
    }
  });

  // Stage interaction (focus move)
  let draggingFocus = false;

  stage.addEventListener("pointerdown", (e) => {
    if(!stageW || !stageH) return;
    draggingFocus = true;
    stage.setPointerCapture(e.pointerId);

    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
    e.preventDefault();
  });

  stage.addEventListener("pointermove", (e) => {
    if(!draggingFocus || !stageW || !stageH) return;
    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
    e.preventDefault();
  });

  stage.addEventListener("pointerup", () => { draggingFocus = false; });
  stage.addEventListener("pointercancel", () => { draggingFocus = false; });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.target && ["INPUT","SELECT","TEXTAREA"].includes(e.target.tagName)) return;

    if(e.code === "ArrowLeft"){ e.preventDefault(); stepAdjacent(-1); }
    if(e.code === "ArrowRight"){ e.preventDefault(); stepAdjacent(+1); }

    if(e.code === "KeyI"){ e.preventDefault(); markInput.click(); }
    if(e.code === "KeyO"){ e.preventDefault(); markOutput.click(); }

    if(e.code === "KeyJ"){ e.preventDefault(); prevMarker.click(); }
    if(e.code === "KeyK"){ e.preventDefault(); nextMarker.click(); }

    if(e.code === "Space"){ e.preventDefault(); stepPlay.click(); }
  });

  // Init
  enableControls(false);
  updateStageTransform();
  updateMagUI();
  updateTimeScaleUI();
  updateVfrDisp();
  updateCurrentSummary();
  renderMarkers();
  renderMeasures();
})();
</script>
</body>
</html>
