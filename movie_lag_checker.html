<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</title>
  <style>
    :root {
      --bg: #05070d;
      --panel: rgba(18, 26, 40, 0.86);
      --panel2: rgba(18, 26, 40, 0.65);
      --text: #e8eef7;
      --muted: rgba(232,238,247,.70);
      --line: rgba(88, 120, 170, 0.35);
      --accent: rgba(58,123,213,.95);
      --danger: rgba(255,107,107,.95);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    html, body { height: 100%; background: radial-gradient(1200px 800px at 20% 10%, #0e1a2f 0%, #05070d 60%); color: var(--text); margin: 0; font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; }
    * { box-sizing: border-box; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .panel { background: var(--panel); border: 1px solid var(--line); border-radius: 18px; box-shadow: var(--shadow); padding: 14px; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 14px; padding-bottom: 40px; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row + .row { margin-top: 10px; }
    .pill { display:flex; align-items:center; gap:8px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--line); background: var(--panel2); }
    .pill label { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color: var(--muted); font-size: 12px; }
    button, input[type="file"]::file-selector-button {
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:hover { background: rgba(18, 26, 40, 0.75); border-color: rgba(88,120,170,.55); }
    button:active { transform: scale(0.99); }
    button.accent { border-color: rgba(58,123,213,.75); background: rgba(58,123,213,.22); }
    button.danger { border-color: rgba(255,107,107,.75); background: rgba(255,107,107,.18); }
    button.mini { padding: 8px 10px; font-size: 13px; border-radius: 12px; }
    button:disabled { opacity: 0.45; cursor: not-allowed; transform:none; }
    select, input[type="range"]{
      accent-color: var(--accent);
    }
    select{
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 14px;
    }

    .video-shell {
      width: 100%;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .stage-wrap{
      display:flex;
      justify-content:center;
      align-items:center;
      width:100%;
      min-height: 220px;
      padding: 14px;
    }
    .stage {
      position: relative;
      max-width: 100%;
      max-height: 70vh;
      border-radius: 14px;
      overflow:hidden;
      background: #000;
      touch-action: none;
    }
    video{
      display:block;
      max-width: 100%;
      max-height: 70vh;
      background: #000;
    }

    .focus-rect {
      position:absolute;
      border:2px solid;
      border-radius: 10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.10) inset;
      pointer-events: none;
      opacity: .70;
    }
    .focus-rect.active { opacity: 1.0; }
    .focus-a { border-color: rgba(58,123,213,.95); }
    .focus-b { border-color: rgba(255,107,107,.95); }

    .crosshair::before, .crosshair::after{
      content:"";
      position:absolute;
      background: rgba(232,238,247,.85);
      opacity:.65;
    }
    .crosshair::before{ left: 50%; top: 6px; width: 2px; height: calc(100% - 12px); transform: translateX(-1px); border-radius: 2px; }
    .crosshair::after{ top: 50%; left: 6px; height: 2px; width: calc(100% - 12px); transform: translateY(-1px); border-radius: 2px; }

    .bar{
      display:flex; align-items:center; gap:10px; padding: 10px 12px;
      border-top: 1px solid var(--line);
      background: rgba(18,26,40,.35);
    }
    .bar input[type="range"]{ width: 100%; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    @media (max-width: 880px){
      .grid{ grid-template-columns: 1fr; }
    }

    .list{
      max-height: 210px;
      overflow:auto;
      padding-right: 6px;
    }
    .item{
      border: 1px solid var(--line);
      background: rgba(18,26,40,.35);
      border-radius: 14px;
      padding: 10px;
      margin-bottom: 8px;
      cursor: pointer;
    }
    .item:hover{ border-color: rgba(88,120,170,.55); }
    .item .top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .badge{
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
    }
    .badge.input{ border-color: rgba(58,123,213,.75); color: rgba(58,123,213,1); background: rgba(58,123,213,.10); }
    .badge.output{ border-color: rgba(255,107,107,.75); color: rgba(255,107,107,1); background: rgba(255,107,107,.08); }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
      margin-top: 8px;
    }

    /* ---- magnifiers (2) */
    .mag {
      position: fixed;
      width: 220px;        /* ←初期値。JSでmagSizeに合わせて上書きします */
      height: auto;
      background:#070a10;
      border:1px solid #223049;
      border-radius: 14px;
      overflow:hidden;
      box-shadow: 0 8px 26px rgba(0,0,0,.35);
      z-index: 9999;
      touch-action: none;

      display: flex;
      flex-direction: column;
    }
    .mag canvas{
      display:block;
      width:100%;
      height:auto;
      aspect-ratio: 1 / 1; /* 正方形表示にする */
    }

    .mag.mag-a.active { border-color: rgba(58,123,213,.95); }
    .mag.mag-b.active { border-color: rgba(255,107,107,.95); }

    .mag header{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 6px 8px;
      font-size: 12px;
      opacity:.95;
      background:#0d1320;
      border-bottom:1px solid #223049;
      user-select: none;
      cursor: move;          /* ドラッグで移動 */
      touch-action: none;
    }
    .magTitle{ font-weight: 600; }
    .magBtns{ margin-left: auto; display:flex; gap: 6px; align-items:center; }
    .mag header button{ padding: 4px 8px; font-size: 12px; border-radius: 10px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h1>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</h1>

      <div class="row">
        <div class="pill">
          <label>動画</label>
          <input id="file" type="file" accept="video/*" />
        </div>

        <div class="pill">
          <label for="fps">参考FPS</label>
          <select id="fps">
            <option>24</option><option>30</option><option>60</option><option>120</option><option selected>240</option>
          </select>
        </div>

        <div class="pill">
          <label for="zoom">表示ズーム</label>
          <input id="zoom" type="range" min="0.5" max="2.0" step="0.01" value="1.00" />
          <span id="zoomVal" class="mono">1.00x</span>
        </div>

        <button id="rotL" class="mini" title="左に90°回転">↺ 回転</button>
        <button id="rotR" class="mini" title="右に90°回転">↻ 回転</button>

        <div class="pill">
          <label for="magOn">拡大窓</label>
          <input id="magOn" type="checkbox" checked />
        </div>

        <div class="pill">
          <label for="magZoom">拡大倍率</label>
          <input id="magZoom" type="range" min="1" max="8" step="0.1" value="4" />
          <span id="magZoomVal" class="mono">4.0x</span>
        </div>

        <div class="pill">
          <label for="magSize">拡大範囲</label>
          <input id="magSize" type="range" min="60" max="260" step="2" value="140" />
          <span id="magSizeVal" class="mono">140px</span>
        </div>

        <div class="pill">
          <label>位置選択</label>
          <button id="pickA" class="mini accent" type="button">A:ボタン</button>
          <button id="pickB" class="mini" type="button">B:表示</button>
          <span id="pickHint" class="muted">→ 動画をタップで移動</span>
        </div>
      </div>

      <div class="row">
        <div class="video-shell" style="width:100%;">
          <div class="stage-wrap">
            <div id="stage" class="stage">
              <video id="video" playsinline muted preload="auto"></video>
              <div id="focusRectA" class="focus-rect crosshair focus-a"></div>
              <div id="focusRectB" class="focus-rect crosshair focus-b"></div>
            </div>
          </div>

          <div class="bar">
            <button id="toStart">⏮ 先頭</button>
            <button id="stepBack">◀ 1コマ戻る</button>
            <button id="stepPlay" class="accent">▶ 1秒に1コマ</button>
            <button id="pauseBtn">⏸ 停止</button>
            <button id="stepFwd">1コマ進む ▶</button>
            <button id="toEnd">末尾 ⏭</button>

            <div class="pill" style="flex:1; min-width: 220px;">
              <label>シーク</label>
              <input id="seek" type="range" min="0" max="1" step="0.001" value="0" />
              <span class="mono" id="seekNow">0:00.000</span>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="pill">
          <label>表示中フレーム</label>
          <span class="mono">mediaTime:</span>
          <span id="mtNow" class="mono">—</span>
        </div>
        <div class="pill">
          <label>位置</label>
          <span class="mono">currentTime:</span>
          <span id="ctNow" class="mono">—</span>
        </div>
      </div>

      <div class="row">
        <button id="markInput" class="accent">入力を記録</button>
        <button id="markOutput" class="danger">表示反映を記録</button>
        <button id="clearCurrent">現在値クリア</button>
        <button id="prevMarker">← 前のマーカー</button>
        <button id="nextMarker">次のマーカー →</button>
        <button id="copyCurrent">現在の結果をコピー</button>
        <button id="resetVfr">VFR統計リセット</button>
      </div>

      <div class="grid">
        <div class="panel" style="padding:12px;">
          <div class="row" style="justify-content: space-between;">
            <div>
              <div class="muted">現在の記録（最後に押した値が正）</div>
              <div id="currentSummary" class="mono" style="margin-top:6px; font-size: 14px; line-height:1.6;"></div>
            </div>
            <div style="text-align:right;">
              <div class="muted">このアプリの前提</div>
              <div class="hint">
                iPhoneの高fps動画はVFRになりやすいので、固定FPS前提の「フレ差×(1000/FPS)」はしません。<br/>
                代わりに requestVideoFrameCallback の mediaTime（秒）で差分を計算します。
              </div>
            </div>
          </div>

          <div class="row" style="margin-top: 8px;">
            <div class="pill">
              <label>VFR揺れ（コマ送り時Δms）</label>
              <span id="vfrDisp" class="mono">—</span>
            </div>
            <div class="pill">
              <label>参考：1フレms</label>
              <span id="refFrameMs" class="mono">—</span>
            </div>
            <div class="pill">
              <label>参考：差分フレ</label>
              <span id="refFrames" class="mono">—</span>
            </div>
          </div>
        </div>

        <div class="panel" style="padding:12px;">
          <div class="muted">ショートカット: ←/→=コマ送り　I=入力記録　O=反映記録　J/K=前/次マーカー　Space=1秒に1コマON/OFF</div>
          <div class="row" style="margin-top: 10px;">
            <div class="panel" style="padding:10px; flex: 1;">
              <div class="muted">マーカー履歴（クリックでジャンプ）</div>
              <div id="markerList" class="list" style="margin-top:8px;"></div>
            </div>
            <div class="panel" style="padding:10px; flex: 1;">
              <div class="muted">測定履歴（入力+反映が揃った瞬間に追加）</div>
              <div id="measureList" class="list" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- 拡大窓（2つ） -->
<div id="magA" class="mag mag-a" style="display:none; left: 10px; bottom: 10px;">
  <header id="magHeaderA">
    <span class="magTitle">A: ボタン押下</span>
    <span id="magInfoA" class="mono">—</span>
    <div class="magBtns">
      <button id="magSetA" type="button" title="Aの拡大位置を選ぶ">位置</button>
      <button id="magMarkInput" type="button" class="accent" title="入力を記録">入力</button>
    </div>
  </header>
  <canvas id="magCanvasA" width="400" height="400"></canvas>
</div>

<div id="magB" class="mag mag-b" style="display:none; right: 10px; bottom: 10px;">
  <header id="magHeaderB">
    <span class="magTitle">B: 画面表示</span>
    <span id="magInfoB" class="mono">—</span>
    <div class="magBtns">
      <button id="magSetB" type="button" title="Bの拡大位置を選ぶ">位置</button>
      <button id="magMarkOutput" type="button" class="accent" title="表示反映を記録">反映</button>
    </div>
  </header>
  <canvas id="magCanvasB" width="400" height="400"></canvas>
</div>

<script>
(() => {
  // ---- dom
  const $ = (id) => document.getElementById(id);

  const file = $("file");
  const video = $("video");
  const stage = $("stage");
  const focusRectA = $("focusRectA");
  const focusRectB = $("focusRectB");

  const fpsSel = $("fps");
  const zoom = $("zoom");
  const zoomVal = $("zoomVal");
  const rotL = $("rotL");
  const rotR = $("rotR");

  const magOn = $("magOn");

  // 位置選択（どちらの拡大位置を動かすか）
  const pickA = $("pickA");
  const pickB = $("pickB");
  const pickHint = $("pickHint");

  // 拡大窓 A/B
  const magA = $("magA");
  const magCanvasA = $("magCanvasA");
  const magCtxA = magCanvasA.getContext("2d");
  const magInfoA = $("magInfoA");
  const magHeaderA = $("magHeaderA");
  const magSetA = $("magSetA");
  const magMarkInput = $("magMarkInput");

  const magB = $("magB");
  const magCanvasB = $("magCanvasB");
  const magCtxB = magCanvasB.getContext("2d");
  const magInfoB = $("magInfoB");
  const magHeaderB = $("magHeaderB");
  const magSetB = $("magSetB");
  const magMarkOutput = $("magMarkOutput");

  const magZoom = $("magZoom");
  const magZoomVal = $("magZoomVal");
  const magSize = $("magSize");
  const magSizeVal = $("magSizeVal");

  const seek = $("seek");
  const seekNow = $("seekNow");
  const toStart = $("toStart");
  const toEnd = $("toEnd");
  const stepBack = $("stepBack");
  const stepFwd = $("stepFwd");
  const stepPlay = $("stepPlay");
  const pauseBtn = $("pauseBtn");

  const mtNow = $("mtNow");
  const ctNow = $("ctNow");

  const markInput = $("markInput");
  const markOutput = $("markOutput");
  const clearCurrent = $("clearCurrent");

  const prevMarker = $("prevMarker");
  const nextMarker = $("nextMarker");

  const copyCurrent = $("copyCurrent");
  const resetVfr = $("resetVfr");

  const currentSummary = $("currentSummary");
  const vfrDisp = $("vfrDisp");
  const refFrameMs = $("refFrameMs");
  const refFrames = $("refFrames");

  const markerList = $("markerList");
  const measureList = $("measureList");

  // ---- state
  let rotation = 0;         // degrees
  let viewZoom = 1.00;      // stage transform zoom
  let stageW = 0;           // CSS px (untransformed)
  let stageH = 0;

  // rvfc
  let rvfcId = null;

  // last VideoFrameMetadata
  let curMeta = null;
  let curMediaTime = null;  // seconds
  let curCurrentTime = null;

  let stepTimer = null;
  let busy = false;
  let magDragInit = false;

  // Focus rects (in stage CSS px, untransformed coordinates)
  let focusA = { x: 0, y: 0, size: 140 };
  let focusB = { x: 0, y: 0, size: 140 };
  let activePick = "A"; // "A" or "B"

  // Marks (current)
  let inputMark = null;   // {t: mediaTimeSec, at: Date, kind:'input'}
  let outputMark = null;  // {t: mediaTimeSec, at: Date, kind:'output'}

  // History
  let markers = [];       // {id, kind, t, createdAt}
  let markerSel = -1;
  let measures = [];      // {id, inputT, outputT, deltaMs, createdAt}

  // VFR stats (only for "step" actions)
  let vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };

  // ---- utils
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const getFpsRef = () => Number(fpsSel.value || 240);

  function fmtTime(sec){
    if(sec == null || !Number.isFinite(sec)) return "—";
    sec = Math.max(0, sec);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec - Math.floor(sec)) * 1000);
    return `${m}:${String(s).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
  }

  function safeUUID(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function enableControls(on){
    const btns = [toStart,toEnd,stepBack,stepFwd,stepPlay,pauseBtn,seek,markInput,markOutput,clearCurrent,prevMarker,nextMarker,copyCurrent,resetVfr];
    btns.forEach(b => b.disabled = !on);
  }

  function updateStageTransform(){
    viewZoom = Number(zoom.value);
    zoomVal.textContent = `${viewZoom.toFixed(2)}x`;

    const t = `rotate(${rotation}deg) scale(${viewZoom})`;
    video.style.transformOrigin = "center center";
    video.style.transform = t;

    // focus rects are in stage coordinates; keep them aligned by applying same transform to video only.
    // We compute stage<->video mapping with rotation+zoom.
  }

  function stageToVideoMatrix(){
    // Map stage (CSS px, untransformed) to video pixel coords.
    // We use client sizes rather than transformed sizes.
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if(!vw || !vh || !stageW || !stageH) return null;

    // scale from stage CSS px to video px (before rotation/zoom)
    const sx = vw / stageW;
    const sy = vh / stageH;

    return { sx, sy };
  }

  function clientToStageXY(clientX, clientY){
    const r = stage.getBoundingClientRect();
    // stage rect includes padding? stage itself, so okay.
    const x = clientX - r.left;
    const y = clientY - r.top;
    // Undo viewZoom and rotation around center for mapping pointer to "untransformed stage coords"
    const cx = r.width / 2;
    const cy = r.height / 2;

    let dx = x - cx;
    let dy = y - cy;

    // undo scale
    dx /= viewZoom;
    dy /= viewZoom;

    // undo rotation
    const rad = (-rotation) * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    const ux = dx*cos - dy*sin;
    const uy = dx*sin + dy*cos;

    return { x: ux + stageW/2, y: uy + stageH/2 };
  }

  function stageXYToVideoXY(stageX, stageY){
    const M = stageToVideoMatrix();
    if(!M) return null;

    // convert stage coords -> unrotated/unscaled stage coords centered? Stage coords are already in untransformed space.
    // Just scale to video pixels
    const x = stageX * M.sx;
    const y = stageY * M.sy;
    return { x, y, sx: M.sx, sy: M.sy }; // assume uniform scale
  }

  function applyFocusRect(el, f){
    f.size = Number(magSize.value);
    el.style.width = `${f.size}px`;
    el.style.height = `${f.size}px`;
    el.style.left = `${f.x - f.size/2}px`;
    el.style.top  = `${f.y - f.size/2}px`;
  }

  function updateActivePickUI(){
    const isA = activePick === "A";
    pickA.classList.toggle("accent", isA);
    pickB.classList.toggle("accent", !isA);

    focusRectA.classList.toggle("active", isA);
    focusRectB.classList.toggle("active", !isA);

    magA.classList.toggle("active", isA);
    magB.classList.toggle("active", !isA);
  }

  function updateFocusRects(){
    applyFocusRect(focusRectA, focusA);
    applyFocusRect(focusRectB, focusB);
    updateActivePickUI();
  }

  function updateMagUI(){
    magZoomVal.textContent = `${Number(magZoom.value).toFixed(1)}x`;
    magSizeVal.textContent = `${Number(magSize.value)}px`;

    const win = Number(magSize.value);
    magA.style.width = `${win}px`;
    magB.style.width = `${win}px`;

    const dpr = window.devicePixelRatio || 1;
    const px = Math.max(64, Math.round(win * dpr)); // win=magSize(px)
    magCanvasA.width = px;
    magCanvasA.height = px;
    magCanvasB.width = px;
    magCanvasB.height = px;

    // 窓サイズ変更後に画面外へはみ出ないようにする（既に関数がある前提）
    clampMagToViewport(magA);
    clampMagToViewport(magB);

    const on = magOn.checked;
    const hasVideo = !!video.videoWidth && !!video.videoHeight && !!stageW && !!stageH;

    // 拡大窓の表示/非表示（動画が読み込まれるまでは隠す）
    magA.style.display = (on && hasVideo) ? "" : "none";
    magB.style.display = (on && hasVideo) ? "" : "none";

    // フォーカス枠も連動
    focusRectA.style.display = (on && hasVideo) ? "" : "none";
    focusRectB.style.display = (on && hasVideo) ? "" : "none";

    updateFocusRects();
  }

  function updateSeekMax(){
    const d = video.duration;
    if(Number.isFinite(d) && d > 0){
      seek.max = d;
      seek.step = 0.001;
    }else{
      seek.max = 1;
    }
  }

  function updateSeekNow(){
    const t = video.currentTime || 0;
    seek.value = t;
    seekNow.textContent = fmtTime(t);
  }

  function updateNowLabels(){
    mtNow.textContent = fmtTime(curMediaTime);
    ctNow.textContent = fmtTime(curCurrentTime);
  }

  function updateVfrDisp(){
    if(vfr.n <= 0 || !Number.isFinite(vfr.min) || !Number.isFinite(vfr.max)){
      vfrDisp.textContent = "—";
    }else{
      const avg = vfr.sum / vfr.n;
      vfrDisp.textContent = `min ${vfr.min.toFixed(2)} / max ${vfr.max.toFixed(2)} / avg ${avg.toFixed(2)} ms (n=${vfr.n})`;
    }

    const fps = getFpsRef();
    const ms = 1000 / fps;
    refFrameMs.textContent = `${ms.toFixed(3)} ms`;
    if(inputMark && outputMark){
      const delta = (outputMark.t - inputMark.t) * 1000;
      refFrames.textContent = `${(delta/ms).toFixed(2)} f`;
    }else{
      refFrames.textContent = "—";
    }
  }

  function updateCurrentSummary(){
    let html = "";
    if(!inputMark) html += `入力: <b>未記録</b><br/>`;
    else html += `入力: <b>${fmtTime(inputMark.t)}</b><br/>`;
    if(!outputMark) html += `反映: <b>未記録</b><br/>`;
    else html += `反映: <b>${fmtTime(outputMark.t)}</b><br/>`;

    if(inputMark && outputMark){
      const deltaMs = (outputMark.t - inputMark.t) * 1000;
      html += `差分: <b>${deltaMs.toFixed(2)} ms</b>（FPSは参考表示のみです）<br/>`;
    }else{
      html += `差分: <b>—</b><br/>`;
    }
    currentSummary.innerHTML = html;
    updateVfrDisp();
  }

  function renderMarkers(){
    markerList.innerHTML = "";
    if(!markers.length){
      markerList.innerHTML = `<div class="muted">まだマーカーがありません</div>`;
      return;
    }

    markers.slice().reverse().forEach((m, idxRev) => {
      const idx = markers.length - 1 - idxRev;
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge ${m.kind}">${m.kind === "input" ? "入力" : "反映"}</span>
          <span class="mono">${fmtTime(m.t)}</span>
        </div>
        <div class="muted">#${idx+1} / ${new Date(m.createdAt).toLocaleString()}</div>
      `;
      el.addEventListener("click", async () => {
        stopStepPlay();
        markerSel = idx;
        await seekTo(m.t);
      });
      markerList.appendChild(el);
    });
  }

  function renderMeasures(){
    measureList.innerHTML = "";
    if(!measures.length){
      measureList.innerHTML = `<div class="muted">まだ測定履歴がありません</div>`;
      return;
    }
    measures.slice().reverse().forEach((m) => {
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge">Δ</span>
          <span class="mono"><b>${m.deltaMs.toFixed(2)} ms</b></span>
        </div>
        <div class="muted mono">input ${fmtTime(m.inputT)} / output ${fmtTime(m.outputT)}</div>
        <div class="muted">${new Date(m.createdAt).toLocaleString()}</div>
      `;
      measureList.appendChild(el);
    });
  }

  function pushMarker(kind, t){
    const id = safeUUID();
    markers.push({ id, kind, t, createdAt: Date.now() });
    renderMarkers();
  }

  function pushMeasure(inputT, outputT){
    const id = safeUUID();
    const deltaMs = (outputT - inputT) * 1000;
    measures.push({ id, inputT, outputT, deltaMs, createdAt: Date.now() });
    renderMeasures();
  }

  // ---- rvfc
  let frameSeq = 0;
  let frameWaiters = [];

  function waitFrameAfter(seq, timeoutMs = 800){
    return new Promise((resolve) => {
      const waiter = { minSeq: seq + 1, resolve: null, timer: null };
      waiter.resolve = (ok) => {
        if(waiter.timer) clearTimeout(waiter.timer);
        resolve(ok);
      };
      waiter.timer = setTimeout(() => waiter.resolve(false), timeoutMs);
      frameWaiters.push(waiter);
    });
  }

  function onFrame(now, meta){
    frameSeq++;

    curMeta = meta;
    curMediaTime = (meta && Number.isFinite(meta.mediaTime)) ? meta.mediaTime : null;
    curCurrentTime = video.currentTime;

    updateNowLabels();
    updateSeekNow();
    updateCurrentSummary();
    drawMagnifiers();

    // release waiters
    if(frameWaiters.length){
      const remain = [];
      for(const w of frameWaiters){
        if(frameSeq >= w.minSeq) w.resolve(true);
        else remain.push(w);
      }
      frameWaiters = remain;
    }

    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  function startRvfc(){
    if(rvfcId != null) return;
    if(typeof video.requestVideoFrameCallback !== "function"){
      // Fallback: update via rAF (less accurate for VFR)
      const tick = () => {
        curCurrentTime = video.currentTime;
        curMediaTime = video.currentTime;
        updateNowLabels();
        updateSeekNow();
        updateCurrentSummary();
        drawMagnifiers();
        rvfcId = requestAnimationFrame(tick);
      };
      rvfcId = requestAnimationFrame(tick);
      return;
    }
    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  function stopRvfc(){
    if(rvfcId == null) return;
    if(typeof video.cancelVideoFrameCallback === "function"){
      try{ video.cancelVideoFrameCallback(rvfcId); }catch{}
    }else{
      cancelAnimationFrame(rvfcId);
    }
    rvfcId = null;
  }

  async function seekTo(t){
    const d = Number.isFinite(video.duration) ? video.duration : 0;
    t = clamp(t, 0, d);

    const beforeSeq = frameSeq;

    await new Promise(resolve => {
      const onSeeked = () => resolve();
      video.addEventListener("seeked", onSeeked, { once:true });
      if(typeof video.fastSeek === "function") video.fastSeek(t);
      else video.currentTime = t;
    });

    await waitFrameAfter(beforeSeq, 800);
  }

  // ---- step play
  function stopStepPlay(){
    if(stepTimer){
      clearInterval(stepTimer);
      stepTimer = null;
    }
    stepPlay.textContent = "▶ 1秒に1コマ";
  }

  async function stepAdjacent(direction, fromAuto = false){
    if(busy) return;
    busy = true;

    try{
      if(!fromAuto) stopStepPlay();
      video.pause();

      const startMT = (curMediaTime ?? video.currentTime);
      const startCT = video.currentTime;

      const d = Number.isFinite(video.duration) ? video.duration : 0;
      if(!d) return;

      let delta = (1 / getFpsRef()) * 0.6;
      let changed = false;

      for(let i=0; i<18; i++){
        const target = clamp(startCT + direction * delta, 0, d);
        await seekTo(target);

        const mt = (curMediaTime ?? video.currentTime);

        if(Number.isFinite(mt) && Math.abs(mt - startMT) > 1e-9){
          changed = true;

          const dtMs = Math.abs((mt - startMT) * 1000);
          if(Number.isFinite(dtMs) && dtMs > 0){
            vfr.min = Math.min(vfr.min, dtMs);
            vfr.max = Math.max(vfr.max, dtMs);
            vfr.sum += dtMs;
            vfr.n += 1;
          }
          break;
        }
        delta *= 1.7;
      }

      if(!changed){
        const fallback = clamp(startCT + direction * 0.05, 0, d);
        await seekTo(fallback);
      }

    } finally {
      busy = false;
    }
  }

  // ---- magnifiers
  function drawMagnifierOne(which, f, magEl, canvas, ctx, infoEl){
    if(!magOn.checked) return;
    if(magEl.style.display === "none") return;
    if(!video.videoWidth || !video.videoHeight || !stageW || !stageH) return;

    const vpos = stageXYToVideoXY(f.x, f.y);
    if(!vpos) return;

    const mz = Number(magZoom.value);
    const outW = canvas.width;
    const outH = canvas.height;

    const cropW = (f.size * vpos.sx) / mz;
    const cropH = (f.size * vpos.sy) / mz;

    const sx = clamp(vpos.x - cropW/2, 0, video.videoWidth - cropW);
    const sy = clamp(vpos.y - cropH/2, 0, video.videoHeight - cropH);

    ctx.clearRect(0,0,outW,outH);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, outW, outH);

    ctx.strokeStyle = (which === "A") ? "rgba(58,123,213,.95)" : "rgba(255,107,107,.95)";
    ctx.lineWidth = 3;
    ctx.strokeRect(6,6,outW-12,outH-12);

    ctx.strokeStyle = "rgba(232,238,247,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(outW/2, 10); ctx.lineTo(outW/2, outH-10);
    ctx.moveTo(10, outH/2); ctx.lineTo(outW-10, outH/2);
    ctx.stroke();

    infoEl.textContent = `mt ${fmtTime(curMediaTime)} / x${mz.toFixed(1)}`;
  }

  function drawMagnifiers(){
    if(!magOn.checked) return;
    drawMagnifierOne("A", focusA, magA, magCanvasA, magCtxA, magInfoA);
    drawMagnifierOne("B", focusB, magB, magCanvasB, magCtxB, magInfoB);
  }

  // ---- events
  zoom.addEventListener("input", () => updateStageTransform());
  rotL.addEventListener("click", () => { rotation = (rotation - 90) % 360; updateStageTransform(); });
  rotR.addEventListener("click", () => { rotation = (rotation + 90) % 360; updateStageTransform(); });

  magOn.addEventListener("change", () => updateMagUI());
  magZoom.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });
  magSize.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });

  // ---- 2つの拡大窓：位置選択
  function setActivePick(which){
    activePick = (which === "B") ? "B" : "A";
    updateActivePickUI();
    pickHint.textContent = activePick === "A"
      ? "→ 動画をタップで A を移動"
      : "→ 動画をタップで B を移動";
  }

  pickA.addEventListener("click", () => setActivePick("A"));
  pickB.addEventListener("click", () => setActivePick("B"));
  magSetA.addEventListener("click", () => setActivePick("A"));
  magSetB.addEventListener("click", () => setActivePick("B"));

  // 拡大窓から即記録（押しやすい）
  magMarkInput.addEventListener("click", () => markInput.click());
  magMarkOutput.addEventListener("click", () => markOutput.click());

  // キーボード（PC用）：1=A、2=B
  window.addEventListener("keydown", (e) => {
    if(e.key === "1") setActivePick("A");
    if(e.key === "2") setActivePick("B");
  });

  // ---- 拡大窓をドラッグで移動（位置を保存）
  function normalizeMagPosition(el){
    const r = el.getBoundingClientRect();
    el.style.left = `${r.left}px`;
    el.style.top  = `${r.top}px`;
    el.style.right = "auto";
    el.style.bottom = "auto";
  }

  function clampMagToViewport(el){
    const r = el.getBoundingClientRect();
    const pad = 6;
    let x = r.left, y = r.top;
    x = clamp(x, pad, window.innerWidth - r.width - pad);
    y = clamp(y, pad, window.innerHeight - r.height - pad);
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function saveMagPos(key, el){
    try{
      const r = el.getBoundingClientRect();
      localStorage.setItem(key, JSON.stringify({ x:r.left, y:r.top }));
    }catch{}
  }

  function restoreMagPos(key, el){
    try{
      const v = localStorage.getItem(key);
      if(!v) return;
      const p = JSON.parse(v);
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
      normalizeMagPosition(el);
      el.style.left = `${p.x}px`;
      el.style.top  = `${p.y}px`;
      clampMagToViewport(el);
    }catch{}
  }

  function makeMagDraggable(el, headerEl, key){
    let draggingMag = false;
    let start = null;

    const onDown = (e) => {
      if(!magOn.checked) return;
      draggingMag = true;
      el.setPointerCapture(e.pointerId);
      normalizeMagPosition(el);
      const r = el.getBoundingClientRect();
      start = { px:e.clientX, py:e.clientY, left:r.left, top:r.top };
      e.preventDefault();
    };

    const onMove = (e) => {
      if(!draggingMag || !start) return;
      const dx = e.clientX - start.px;
      const dy = e.clientY - start.py;
      el.style.left = `${start.left + dx}px`;
      el.style.top  = `${start.top + dy}px`;
      clampMagToViewport(el);
      e.preventDefault();
    };

    const onUp = (e) => {
      if(!draggingMag) return;
      draggingMag = false;
      start = null;
      try{ el.releasePointerCapture(e.pointerId); }catch{}
      saveMagPos(key, el);
      e.preventDefault();
    };

    headerEl.addEventListener("pointerdown", onDown);
    headerEl.addEventListener("pointermove", onMove);
    headerEl.addEventListener("pointerup", onUp);
    headerEl.addEventListener("pointercancel", onUp);
  }

  toStart.addEventListener("click", async () => { stopStepPlay(); await seekTo(0); });
  toEnd.addEventListener("click", async () => { stopStepPlay(); await seekTo(video.duration || 0); });

  stepBack.addEventListener("click", async () => { await stepAdjacent(-1); });
  stepFwd.addEventListener("click", async () => { await stepAdjacent(+1); });

  pauseBtn.addEventListener("click", () => { stopStepPlay(); video.pause(); });

  stepPlay.addEventListener("click", () => {
    if(stepTimer){
      stopStepPlay();
      return;
    }
    stepPlay.textContent = "⏱ 1秒に1コマ（ON）";
    video.pause();
    stepTimer = setInterval(() => stepAdjacent(+1, true), 1000);
  });

  seek.addEventListener("input", async () => {
    stopStepPlay();
    const t = Number(seek.value);
    await seekTo(t);
  });

  markInput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    inputMark = { t: curMediaTime, at: new Date(), kind:"input" };
    pushMarker("input", inputMark.t);
    updateCurrentSummary();
  });

  markOutput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    outputMark = { t: curMediaTime, at: new Date(), kind:"output" };
    pushMarker("output", outputMark.t);

    if(inputMark){
      pushMeasure(inputMark.t, outputMark.t);
    }
    updateCurrentSummary();
  });

  clearCurrent.addEventListener("click", () => {
    inputMark = null;
    outputMark = null;
    updateCurrentSummary();
  });

  prevMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel <= 0) ? (markers.length - 1) : (markerSel - 1);
    await seekTo(markers[markerSel].t);
  });

  nextMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel >= markers.length - 1) ? 0 : (markerSel + 1);
    await seekTo(markers[markerSel].t);
  });

  copyCurrent.addEventListener("click", async () => {
    const inT = inputMark ? inputMark.t : null;
    const outT = outputMark ? outputMark.t : null;
    const deltaMs = (inT != null && outT != null) ? ((outT - inT) * 1000) : null;
    const text =
`inputTime(mediaTime): ${inT != null ? fmtTime(inT) : "—"}
displayTime(mediaTime): ${outT != null ? fmtTime(outT) : "—"}
deltaMs: ${deltaMs != null ? deltaMs.toFixed(2) : "—"} ms`;
    try{
      await navigator.clipboard.writeText(text);
    }catch{
      alert(text);
    }
  });

  resetVfr.addEventListener("click", () => {
    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    updateVfrDisp();
  });

  file.addEventListener("change", async () => {
    stopStepPlay();
    inputMark = null;
    outputMark = null;
    markers = [];
    measures = [];
    markerSel = -1;
    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    renderMarkers();
    renderMeasures();
    updateVfrDisp();
    updateCurrentSummary();

    const f = file.files?.[0];
    if(!f) return;

    if(video.src && video.src.startsWith("blob:")){
      try { URL.revokeObjectURL(video.src); } catch {}
    }

    const url = URL.createObjectURL(f);

    video.src = url;
    video.preload = "auto";
    video.muted = true;
    video.playsInline = true;
    video.load();

    try{
      await video.play();
      video.pause();
      video.currentTime = 0;
    }catch(e){
      console.log("prime play failed:", e);
    }
  });

  video.addEventListener("error", () => {
    const err = video.error;
    alert(`動画の読み込みに失敗しました（error code: ${err?.code ?? "?"}）\n別形式（H.264 mp4等）に変換すると再生できることがあります。`);
  });

  video.addEventListener("loadedmetadata", () => {
    enableControls(true);
    updateSeekMax();

    // stageW/H: video element client size (untransformed)
    const ro = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        stageW = video.clientWidth;
        stageH = video.clientHeight;

        if((focusA.x === 0 && focusA.y === 0) && (focusB.x === 0 && focusB.y === 0)){
          focusA.x = stageW * 0.35;
          focusA.y = stageH * 0.50;
          focusB.x = stageW * 0.65;
          focusB.y = stageH * 0.50;
        }
        updateFocusRects();
        drawMagnifiers();
        updateMagUI();
      });
    });
    ro.observe(video);

    startRvfc();
    updateMagUI();

    // 拡大窓ドラッグ＆位置復元
    restoreMagPos("magA_pos", magA);
    restoreMagPos("magB_pos", magB);
    if(!magDragInit){
      makeMagDraggable(magA, magHeaderA, "magA_pos");
      makeMagDraggable(magB, magHeaderB, "magB_pos");
      magDragInit = true;
    }

    // 初期はAを選択
    setActivePick("A");
  });

  // stage tap/drag -> move active focus rect
  let dragging = false;
  stage.addEventListener("pointerdown", (e) => {
    if(!stageW || !stageH) return;
    dragging = true;
    stage.setPointerCapture(e.pointerId);
    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
  });
  stage.addEventListener("pointermove", (e) => {
    if(!dragging) return;
    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
  });
  stage.addEventListener("pointerup", () => { dragging = false; });

  // keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.target && ["INPUT","SELECT","TEXTAREA"].includes(e.target.tagName)) return;

    if(e.code === "ArrowLeft"){ e.preventDefault(); stepAdjacent(-1); }
    if(e.code === "ArrowRight"){ e.preventDefault(); stepAdjacent(+1); }

    if(e.code === "KeyI"){ e.preventDefault(); markInput.click(); }
    if(e.code === "KeyO"){ e.preventDefault(); markOutput.click(); }

    if(e.code === "KeyJ"){ e.preventDefault(); prevMarker.click(); }
    if(e.code === "KeyK"){ e.preventDefault(); nextMarker.click(); }

    if(e.code === "Space"){ e.preventDefault(); stepPlay.click(); }
  });

  // init
  enableControls(false);
  renderMarkers();
  renderMeasures();
  updateMagUI();
  updateStageTransform();
  updateVfrDisp();
})();
</script>
</body>
</html>
