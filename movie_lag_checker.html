<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</title>

  <style>
    :root {
      --bg: #05070d;
      --panel: rgba(18, 26, 40, 0.86);
      --panel2: rgba(18, 26, 40, 0.65);
      --text: #e8eef7;
      --muted: rgba(232,238,247,.70);
      --line: rgba(88, 120, 170, 0.35);
      --accent: rgba(58,123,213,.95);
      --danger: rgba(255,107,107,.95);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
    }

    html, body {
      height: 100%;
      background: radial-gradient(1200px 800px at 20% 10%, #0e1a2f 0%, #05070d 60%);
      color: var(--text);
      margin: 0;
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif;
    }
    * { box-sizing: border-box; }
    h1 { font-size: 18px; margin: 0 0 10px; }

    .wrap { max-width: 1120px; margin: 0 auto; padding: 14px; padding-bottom: 40px; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row + .row { margin-top: 10px; }

    .pill {
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--panel2);
    }
    .pill label { font-size: 12px; color: var(--muted); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color: var(--muted); font-size: 12px; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.5; margin-top: 8px; }

    button, input[type="file"]::file-selector-button {
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .04s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:hover { background: rgba(18, 26, 40, 0.75); border-color: rgba(88,120,170,.55); }
    button:active { transform: scale(0.99); }
    button.accent { border-color: rgba(58,123,213,.75); background: rgba(58,123,213,.22); }
    button.danger { border-color: rgba(255,107,107,.75); background: rgba(255,107,107,.18); }
    button.mini { padding: 8px 10px; font-size: 13px; border-radius: 12px; }
    button:disabled { opacity: 0.45; cursor: not-allowed; transform:none; }

    select, input[type="range"]{ accent-color: var(--accent); }
    select{
      border: 1px solid var(--line);
      background: rgba(18, 26, 40, 0.55);
      color: var(--text);
      border-radius: 14px;
      padding: 8px 10px;
      font-size: 14px;
    }

    .video-shell {
      width: 100%;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    .stage-wrap{
      display:flex;
      justify-content:center;
      align-items:center;
      width:100%;
      min-height: 220px;
      padding: 14px;
    }

    .stage {
      position: relative;
      max-width: 100%;
      max-height: 70vh;
      border-radius: 14px;
      overflow:hidden;
      background: #000;
      touch-action: none; /* avoid scroll while dragging focus */
    }

    #content {
      position: relative;
      display: inline-block;
      transform-origin: center center;
    }

    video{
      display:block;
      max-width: 100%;
      max-height: 70vh;
      background: #000;
    }

    .focus-rect {
      position:absolute;
      border:2px solid;
      border-radius: 10px;
      box-shadow: 0 0 0 9999px rgba(0,0,0,.10) inset;
      pointer-events: none;
      opacity: .70;
    }
    .focus-rect.active { opacity: 1.0; }
    .focus-a { border-color: rgba(58,123,213,.95); }
    .focus-b { border-color: rgba(255,107,107,.95); }

    .crosshair::before, .crosshair::after{
      content:"";
      position:absolute;
      background: rgba(232,238,247,.85);
      opacity:.65;
    }
    .crosshair::before{ left: 50%; top: 6px; width: 2px; height: calc(100% - 12px); transform: translateX(-1px); border-radius: 2px; }
    .crosshair::after{ top: 50%; left: 6px; height: 2px; width: calc(100% - 12px); transform: translateY(-1px); border-radius: 2px; }

    .bar{
      display:flex; align-items:center; gap:10px; padding: 10px 12px;
      border-top: 1px solid var(--line);
      background: rgba(18,26,40,.35);
    }
    .bar input[type="range"]{ width: 100%; }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    .histRow{
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 10px;
      align-items: stretch;
    }
    .histCol{
      flex: 1;
      min-width: 380px;
    }

    .list{
      max-height: min(70vh, 720px);
      min-height: 520px;
      overflow:auto;
      padding-right: 6px;
    }

    @media (max-width: 540px){
      .histCol{ min-width: 100%; }
      .list{
        min-height: 320px;
        max-height: 55vh;
      }
      .bar{
        flex-wrap: wrap;
      }
    }

    .item{
      border: 1px solid var(--line);
      background: rgba(18,26,40,.35);
      border-radius: 14px;
      padding: 10px;
      margin-bottom: 8px;
      cursor: pointer;
    }
    .item:hover{ border-color: rgba(88,120,170,.55); }
    .item .top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }

    .badge{
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
    }
    .badge.input{ border-color: rgba(58,123,213,.75); color: rgba(58,123,213,1); background: rgba(58,123,213,.10); }
    .badge.output{ border-color: rgba(255,107,107,.75); color: rgba(255,107,107,1); background: rgba(255,107,107,.08); }

    /* ---- magnifiers (2) */
    .mag {
      position: fixed;
      width: 220px;     /* JS will override by magSize */
      background:#070a10;
      border:1px solid #223049;
      border-radius: 14px;
      overflow:hidden;
      box-shadow: 0 8px 26px rgba(0,0,0,.35);
      z-index: 9999;
      touch-action: none;
      display: flex;
      flex-direction: column;
    }
    .mag.mag-a.active { border-color: rgba(58,123,213,.95); }
    .mag.mag-b.active { border-color: rgba(255,107,107,.95); }

    .mag header{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 6px 8px;
      font-size: 12px;
      opacity:.95;
      background:#0d1320;
      border-bottom:1px solid #223049;
      user-select: none;

      cursor: move;           /* 十字アイコン */
      touch-action: none;     /* iPhoneでスワイプ移動を成立させる */
    }
    .mag header.dragging{
      cursor: move;
    }

    .magTitle{ font-weight: 600; }
    .magBtns{ margin-left: auto; display:flex; gap: 6px; align-items:center; }
    .mag header button{ padding: 4px 8px; font-size: 12px; border-radius: 10px; }
    .mag canvas{
      display:block;
      width:100%;
      height:auto;
      aspect-ratio: 1 / 1;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h1>SF6 入力→表示 ラグ計測（VFR対応 / mediaTimeで計算）</h1>

      <div class="row">
        <div class="pill">
          <label>動画</label>
          <input id="file" type="file" accept="video/*" />
        </div>

        <div class="pill">
          <label for="fps">参考FPS</label>
          <select id="fps">
            <option>24</option><option>30</option><option>60</option><option>120</option><option selected>240</option>
          </select>
        </div>

        <div class="pill">
          <label for="zoom">表示ズーム</label>
          <input id="zoom" type="range" min="0.5" max="2.0" step="0.01" value="1.00" />
          <span id="zoomVal" class="mono">1.00x</span>
        </div>

        <button id="rotL" class="mini" title="左に90°回転">↺ 回転</button>
        <button id="rotR" class="mini" title="右に90°回転">↻ 回転</button>

        <div class="pill">
          <label for="magOn">拡大窓</label>
          <input id="magOn" type="checkbox" checked />
        </div>

        <div class="pill">
          <label for="magZoom">拡大倍率</label>
          <input id="magZoom" type="range" min="0.25" max="8" step="0.05" value="1.00" />
          <span id="magZoomVal" class="mono">1.0x</span>
        </div>

        <div class="pill">
          <label for="magSize">拡大範囲</label>
          <input id="magSize" type="range" min="80" max="360" step="2" value="220" />
          <span id="magSizeVal" class="mono">220px</span>
        </div>

        <div class="pill">
          <label>拡大位置（A/B）</label>
          <button id="pickA" class="mini accent" type="button">A:ボタン</button>
          <button id="pickB" class="mini" type="button">B:表示</button>
          <span id="pickHint" class="muted">→ 動画をタップ/ドラッグで A を移動</span>
        </div>
      </div>

      <div class="row">
        <div class="video-shell">
          <div class="stage-wrap">
            <div id="stage" class="stage">
              <div id="content">
                <video id="video" playsinline muted preload="auto"></video>
                <div id="focusRectA" class="focus-rect crosshair focus-a"></div>
                <div id="focusRectB" class="focus-rect crosshair focus-b"></div>
              </div>
            </div>
          </div>

          <div class="bar">
            <button id="toStart">⏮ 先頭</button>
            <button id="stepBack">◀ 1コマ戻る</button>
            <button id="stepPlay" class="accent">▶ 1秒に1コマ</button>
            <button id="pauseBtn">⏸ 停止</button>
            <button id="stepFwd">1コマ進む ▶</button>
            <button id="toEnd">末尾 ⏭</button>

            <div class="pill" style="flex:1; min-width: 220px;">
              <label>シーク</label>
              <input id="seek" type="range" min="0" max="1" step="0.001" value="0" />
              <span class="mono" id="seekNow">0:00.000</span>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="pill">
          <label>表示中フレーム</label>
          <span class="mono">mediaTime:</span>
          <span id="mtNow" class="mono">—</span>
        </div>
        <div class="pill">
          <label>位置</label>
          <span class="mono">currentTime:</span>
          <span id="ctNow" class="mono">—</span>
        </div>
      </div>

      <div class="row">
        <button id="markInput" class="accent">入力を記録</button>
        <button id="markOutput" class="danger">表示反映を記録</button>
        <button id="clearCurrent">現在値クリア</button>
        <button id="prevMarker">← 前のマーカー</button>
        <button id="nextMarker">次のマーカー →</button>
        <button id="copyCurrent">現在の結果をコピー</button>
        <button id="resetVfr">VFR統計リセット</button>
      </div>

      <div class="grid">
        <div class="panel" style="padding:12px;">
          <div class="row" style="justify-content: space-between; align-items:flex-start;">
            <div style="flex:1; min-width: 260px;">
              <div class="muted">現在の記録（最後に押した値が正）</div>
              <div id="currentSummary" class="mono" style="margin-top:6px; font-size: 14px; line-height:1.6;"></div>
              <div class="row" style="margin-top: 8px;">
                <div class="pill">
                  <label>VFR揺れ（コマ送り時Δms）</label>
                  <span id="vfrDisp" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>参考：1フレms</label>
                  <span id="refFrameMs" class="mono">—</span>
                </div>
                <div class="pill">
                  <label>参考：差分フレ</label>
                  <span id="refFrames" class="mono">—</span>
                </div>
              </div>
            </div>

            <div style="flex:1; min-width: 260px; text-align:left;">
              <div class="muted">このアプリの前提</div>
              <div class="hint">
                iPhoneの高fps動画はVFRになりやすいので、固定FPS前提の「フレ差×(1000/FPS)」はしません。<br/>
                代わりに requestVideoFrameCallback の mediaTime（秒）で差分を計算します。<br/>
                ショートカット: ←/→=コマ送り　I=入力記録　O=反映記録　J/K=前/次マーカー　Space=1秒に1コマON/OFF
              </div>
            </div>
          </div>

          <div class="histRow">
            <div class="panel histCol" style="padding:10px;">
              <div class="muted">マーカー履歴（クリックでジャンプ）</div>
              <div id="markerList" class="list" style="margin-top:8px;"></div>
            </div>

            <div class="panel histCol" style="padding:10px;">
              <div class="muted">測定履歴（入力+反映が揃った瞬間に追加）</div>
              <div id="measureList" class="list" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- 拡大窓（2つ） -->
  <!-- ※初期位置はleft/topだけに統一（クリックでズレる原因を排除） -->
  <div id="magA" class="mag mag-a" style="display:none; left: 10px; top: 90px;">
    <header id="magHeaderA">
      <span class="magTitle">A: ボタン押下</span>
      <span id="magInfoA" class="mono">—</span>
      <div class="magBtns">
        <button id="magMarkInput" type="button" class="accent" title="入力を記録">入力</button>
      </div>
    </header>
    <canvas id="magCanvasA" width="400" height="400"></canvas>
  </div>

  <div id="magB" class="mag mag-b" style="display:none; left: 260px; top: 90px;">
    <header id="magHeaderB">
      <span class="magTitle">B: 画面表示</span>
      <span id="magInfoB" class="mono">—</span>
      <div class="magBtns">
        <button id="magMarkOutput" type="button" class="accent" title="表示反映を記録">反映</button>
      </div>
    </header>
    <canvas id="magCanvasB" width="400" height="400"></canvas>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // DOM
  const file = $("file");
  const video = $("video");
  const stage = $("stage");
  const content = $("content");

  const focusRectA = $("focusRectA");
  const focusRectB = $("focusRectB");

  const fpsSel = $("fps");
  const zoom = $("zoom");
  const zoomVal = $("zoomVal");
  const rotL = $("rotL");
  const rotR = $("rotR");

  const magOn = $("magOn");
  const pickA = $("pickA");
  const pickB = $("pickB");
  const pickHint = $("pickHint");

  // Magnifiers
  const magA = $("magA");
  const magCanvasA = $("magCanvasA");
  const magCtxA = magCanvasA.getContext("2d");
  const magInfoA = $("magInfoA");
  const magHeaderA = $("magHeaderA");
  const magMarkInput = $("magMarkInput");

  const magB = $("magB");
  const magCanvasB = $("magCanvasB");
  const magCtxB = magCanvasB.getContext("2d");
  const magInfoB = $("magInfoB");
  const magHeaderB = $("magHeaderB");
  const magMarkOutput = $("magMarkOutput");

  const magZoom = $("magZoom");
  const magZoomVal = $("magZoomVal");
  const magSize = $("magSize");
  const magSizeVal = $("magSizeVal");

  // Controls
  const seek = $("seek");
  const seekNow = $("seekNow");
  const toStart = $("toStart");
  const toEnd = $("toEnd");
  const stepBack = $("stepBack");
  const stepFwd = $("stepFwd");
  const stepPlay = $("stepPlay");
  const pauseBtn = $("pauseBtn");

  const mtNow = $("mtNow");
  const ctNow = $("ctNow");

  const markInput = $("markInput");
  const markOutput = $("markOutput");
  const clearCurrent = $("clearCurrent");
  const prevMarker = $("prevMarker");
  const nextMarker = $("nextMarker");
  const copyCurrent = $("copyCurrent");
  const resetVfr = $("resetVfr");

  const currentSummary = $("currentSummary");
  const vfrDisp = $("vfrDisp");
  const refFrameMs = $("refFrameMs");
  const refFrames = $("refFrames");

  const markerList = $("markerList");
  const measureList = $("measureList");

  // State
  let rotation = 0;
  let viewZoom = 1.00;
  let stageW = 0;
  let stageH = 0;

  let rvfcId = null;

  let curMediaTime = null;  // seconds (from mediaTime)
  let curCurrentTime = null;

  let stepTimer = null;
  let busy = false;

  let focusA = { x: 0, y: 0, size: 220 };
  let focusB = { x: 0, y: 0, size: 220 };

  let activePick = "A";

  let inputMark = null;
  let outputMark = null;

  let markers = [];
  let markerSel = -1;
  let measures = [];

  let vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };

  // Utils
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const getFpsRef = () => Number(fpsSel.value || 240);

  function fmtTime(sec){
    if(sec == null || !Number.isFinite(sec)) return "—";
    sec = Math.max(0, sec);
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    const ms = Math.floor((sec - Math.floor(sec)) * 1000);
    return `${m}:${String(s).padStart(2,"0")}.${String(ms).padStart(3,"0")}`;
  }

  function safeUUID(){
    if (crypto?.randomUUID) return crypto.randomUUID();
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
  }

  function enableControls(on){
    const btns = [
      toStart,toEnd,stepBack,stepFwd,stepPlay,pauseBtn,seek,
      markInput,markOutput,clearCurrent,prevMarker,nextMarker,copyCurrent,resetVfr
    ];
    btns.forEach(b => b.disabled = !on);
  }

  function updateStageTransform(){
    viewZoom = Number(zoom.value);
    zoomVal.textContent = `${viewZoom.toFixed(2)}x`;
    const t = `rotate(${rotation}deg) scale(${viewZoom})`;
    content.style.transformOrigin = "center center";
    content.style.transform = t;
  }

  function updateStageSize(){
    stageW = content.clientWidth || video.clientWidth || stage.clientWidth || 0;
    stageH = content.clientHeight || video.clientHeight || stage.clientHeight || 0;
  }

  function stageToVideoMatrix(){
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if(!vw || !vh || !stageW || !stageH) return null;
    return { sx: vw / stageW, sy: vh / stageH };
  }

  function clientToStageXY(clientX, clientY){
    const r = stage.getBoundingClientRect();
    const x = clientX - r.left;
    const y = clientY - r.top;

    const cx = r.width / 2;
    const cy = r.height / 2;

    let dx = x - cx;
    let dy = y - cy;

    dx /= viewZoom;
    dy /= viewZoom;

    const rad = (-rotation) * Math.PI / 180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    const ux = dx*cos - dy*sin;
    const uy = dx*sin + dy*cos;

    return { x: ux + stageW/2, y: uy + stageH/2 };
  }

  function stageXYToVideoXY(stageX, stageY){
    const M = stageToVideoMatrix();
    if(!M) return null;
    return { x: stageX * M.sx, y: stageY * M.sy, sx: M.sx, sy: M.sy };
  }

  function applyFocusRect(el, f){
    f.size = Number(magSize.value);
    el.style.width = `${f.size}px`;
    el.style.height = `${f.size}px`;
    el.style.left = `${f.x - f.size/2}px`;
    el.style.top  = `${f.y - f.size/2}px`;
  }

  function updateActivePickUI(){
    const isA = activePick === "A";
    pickA.classList.toggle("accent", isA);
    pickB.classList.toggle("accent", !isA);

    focusRectA.classList.toggle("active", isA);
    focusRectB.classList.toggle("active", !isA);

    magA.classList.toggle("active", isA);
    magB.classList.toggle("active", !isA);
  }

  function updateFocusRects(){
    applyFocusRect(focusRectA, focusA);
    applyFocusRect(focusRectB, focusB);
    updateActivePickUI();
  }

  function updateSeekMax(){
    const d = video.duration;
    if(Number.isFinite(d) && d > 0){
      seek.max = d;
      seek.step = 0.001;
    }else{
      seek.max = 1;
    }
  }

  function updateSeekNow(){
    const t = video.currentTime || 0;
    seek.value = t;
    seekNow.textContent = fmtTime(t);
  }

  function updateNowLabels(){
    mtNow.textContent = fmtTime(curMediaTime);
    ctNow.textContent = fmtTime(curCurrentTime);
  }

  function updateVfrDisp(){
    if(vfr.n <= 0 || !Number.isFinite(vfr.min) || !Number.isFinite(vfr.max)){
      vfrDisp.textContent = "—";
    }else{
      const avg = vfr.sum / vfr.n;
      vfrDisp.textContent = `min ${vfr.min.toFixed(2)} / max ${vfr.max.toFixed(2)} / avg ${avg.toFixed(2)} ms (n=${vfr.n})`;
    }

    const fps = getFpsRef();
    const ms = 1000 / fps;
    refFrameMs.textContent = `${ms.toFixed(3)} ms`;

    if(inputMark && outputMark){
      const delta = (outputMark.t - inputMark.t) * 1000;
      refFrames.textContent = `${(delta/ms).toFixed(2)} f`;
    }else{
      refFrames.textContent = "—";
    }
  }

  function updateCurrentSummary(){
    let html = "";
    if(!inputMark) html += `入力: <b>未記録</b><br/>`;
    else html += `入力: <b>${fmtTime(inputMark.t)}</b><br/>`;
    if(!outputMark) html += `反映: <b>未記録</b><br/>`;
    else html += `反映: <b>${fmtTime(outputMark.t)}</b><br/>`;

    if(inputMark && outputMark){
      const deltaMs = (outputMark.t - inputMark.t) * 1000;
      html += `差分: <b>${deltaMs.toFixed(2)} ms</b>（FPSは参考表示のみです）<br/>`;
    }else{
      html += `差分: <b>—</b><br/>`;
    }
    currentSummary.innerHTML = html;
    updateVfrDisp();
  }

  function renderMarkers(){
    markerList.innerHTML = "";
    if(!markers.length){
      markerList.innerHTML = `<div class="muted">まだマーカーがありません</div>`;
      return;
    }
    markers.slice().reverse().forEach((m, idxRev) => {
      const idx = markers.length - 1 - idxRev;
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge ${m.kind}">${m.kind === "input" ? "入力" : "反映"}</span>
          <span class="mono">${fmtTime(m.t)}</span>
        </div>
        <div class="muted">#${idx+1} / ${new Date(m.createdAt).toLocaleString()}</div>
      `;
      el.addEventListener("click", async () => {
        stopStepPlay();
        markerSel = idx;
        await seekTo(m.t);
      });
      markerList.appendChild(el);
    });
  }

  function renderMeasures(){
    measureList.innerHTML = "";
    if(!measures.length){
      measureList.innerHTML = `<div class="muted">まだ測定履歴がありません</div>`;
      return;
    }
    measures.slice().reverse().forEach((m) => {
      const el = document.createElement("div");
      el.className = "item";
      el.innerHTML = `
        <div class="top">
          <span class="badge">Δ</span>
          <span class="mono"><b>${m.deltaMs.toFixed(2)} ms</b></span>
        </div>
        <div class="muted mono">input ${fmtTime(m.inputT)} / output ${fmtTime(m.outputT)}</div>
        <div class="muted">${new Date(m.createdAt).toLocaleString()}</div>
      `;
      measureList.appendChild(el);
    });
  }

  function pushMarker(kind, t){
    markers.push({ id: safeUUID(), kind, t, createdAt: Date.now() });
    renderMarkers();
  }

  function pushMeasure(inputT, outputT){
    measures.push({
      id: safeUUID(),
      inputT, outputT,
      deltaMs: (outputT - inputT) * 1000,
      createdAt: Date.now()
    });
    renderMeasures();
  }

  // ---- rvfc
  let frameSeq = 0;
  let frameWaiters = [];

  function waitFrameAfter(seq, timeoutMs = 800){
    return new Promise((resolve) => {
      const waiter = { minSeq: seq + 1, resolve: null, timer: null };
      waiter.resolve = (ok) => {
        if(waiter.timer) clearTimeout(waiter.timer);
        resolve(ok);
      };
      waiter.timer = setTimeout(() => waiter.resolve(false), timeoutMs);
      frameWaiters.push(waiter);
    });
  }

  function onFrame(now, meta){
    frameSeq++;

    curMediaTime = (meta && Number.isFinite(meta.mediaTime)) ? meta.mediaTime : null;
    curCurrentTime = video.currentTime;

    updateNowLabels();
    updateSeekNow();
    updateCurrentSummary();
    drawMagnifiers();

    if(frameWaiters.length){
      const remain = [];
      for(const w of frameWaiters){
        if(frameSeq >= w.minSeq) w.resolve(true);
        else remain.push(w);
      }
      frameWaiters = remain;
    }

    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  function startRvfc(){
    if(rvfcId != null) return;

    if(typeof video.requestVideoFrameCallback !== "function"){
      const tick = () => {
        curCurrentTime = video.currentTime;
        curMediaTime = video.currentTime;
        updateNowLabels();
        updateSeekNow();
        updateCurrentSummary();
        drawMagnifiers();
        rvfcId = requestAnimationFrame(tick);
      };
      rvfcId = requestAnimationFrame(tick);
      return;
    }

    rvfcId = video.requestVideoFrameCallback(onFrame);
  }

  async function seekTo(t){
    const d = Number.isFinite(video.duration) ? video.duration : 0;
    t = clamp(t, 0, d);

    const beforeSeq = frameSeq;

    await new Promise(resolve => {
      const onSeeked = () => resolve();
      video.addEventListener("seeked", onSeeked, { once:true });
      if(typeof video.fastSeek === "function") video.fastSeek(t);
      else video.currentTime = t;
    });

    await waitFrameAfter(beforeSeq, 800);
  }

  // ---- step play
  function stopStepPlay(){
    if(stepTimer){
      clearInterval(stepTimer);
      stepTimer = null;
    }
    stepPlay.textContent = "▶ 1秒に1コマ";
  }

  async function stepAdjacent(direction, fromAuto = false){
    if(busy) return;
    busy = true;

    try{
      if(!fromAuto) stopStepPlay();
      video.pause();

      const startMT = (curMediaTime ?? video.currentTime);
      const startCT = video.currentTime;

      const d = Number.isFinite(video.duration) ? video.duration : 0;
      if(!d) return;

      let delta = (1 / getFpsRef()) * 0.6;
      let changed = false;

      for(let i=0; i<18; i++){
        const target = clamp(startCT + direction * delta, 0, d);
        await seekTo(target);

        const mt = (curMediaTime ?? video.currentTime);

        if(Number.isFinite(mt) && Math.abs(mt - startMT) > 1e-9){
          changed = true;

          const dtMs = Math.abs((mt - startMT) * 1000);
          if(Number.isFinite(dtMs) && dtMs > 0){
            vfr.min = Math.min(vfr.min, dtMs);
            vfr.max = Math.max(vfr.max, dtMs);
            vfr.sum += dtMs;
            vfr.n += 1;
          }
          break;
        }
        delta *= 1.7;
      }

      if(!changed){
        const fallback = clamp(startCT + direction * 0.05, 0, d);
        await seekTo(fallback);
      }
    } finally {
      busy = false;
    }
  }

  // ---- Magnifier window positioning (drag only)
  const DRAG_THRESHOLD_PX = 4;

  function clampMagToViewport(el){
    const r = el.getBoundingClientRect();
    const pad = 6;
    let x = r.left, y = r.top;
    x = clamp(x, pad, window.innerWidth - r.width - pad);
    y = clamp(y, pad, window.innerHeight - r.height - pad);
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }

  function saveMagPos(key, el){
    try{
      const r = el.getBoundingClientRect();
      localStorage.setItem(key, JSON.stringify({ x:r.left, y:r.top }));
    }catch{}
  }

  function restoreMagPos(key, el){
    try{
      const v = localStorage.getItem(key);
      if(!v) return false;
      const p = JSON.parse(v);
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) return false;
      el.style.left = `${p.x}px`;
      el.style.top  = `${p.y}px`;
      clampMagToViewport(el);
      return true;
    }catch{
      return false;
    }
  }

  function ensureDefaultMagPos(){
    const pad = 10;
    const top = Math.round(Math.max(pad, window.innerHeight * 0.12));

    if(!restoreMagPos("magA_pos", magA)){
      magA.style.left = `${pad}px`;
      magA.style.top = `${top}px`;
      clampMagToViewport(magA);
      saveMagPos("magA_pos", magA);
    }

    if(!restoreMagPos("magB_pos", magB)){
      // 右寄せ（left/topで計算）
      const rb = magB.getBoundingClientRect();
      magB.style.left = `${Math.max(pad, window.innerWidth - rb.width - pad)}px`;
      magB.style.top = `${top}px`;
      clampMagToViewport(magB);
      saveMagPos("magB_pos", magB);
    }
  }

  function makeMagDraggable(el, headerEl, key){
    let armed = false;
    let dragging = false;
    let pointerId = null;
    let start = null;

    const ignoreIfButton = (e) => !!e.target.closest("button");

    headerEl.addEventListener("pointerdown", (e) => {
      if(el.style.display === "none") return;
      if(ignoreIfButton(e)) return;

      armed = true;
      dragging = false;
      pointerId = e.pointerId;

      const r = el.getBoundingClientRect();
      start = { px: e.clientX, py: e.clientY, left: r.left, top: r.top };

      headerEl.setPointerCapture(pointerId);
      e.preventDefault();
    });

    headerEl.addEventListener("pointermove", (e) => {
      if(!armed || e.pointerId !== pointerId || !start) return;

      const dx = e.clientX - start.px;
      const dy = e.clientY - start.py;

      // ★一定距離を超えたら「ドラッグ開始」
      if(!dragging){
        if(Math.hypot(dx, dy) < DRAG_THRESHOLD_PX) return;
        dragging = true;
        headerEl.classList.add("dragging");
      }

      el.style.left = `${start.left + dx}px`;
      el.style.top  = `${start.top + dy}px`;
      clampMagToViewport(el);
      e.preventDefault();
    });

    const end = (e) => {
      if(!armed || e.pointerId !== pointerId) return;
      armed = false;

      try{ headerEl.releasePointerCapture(pointerId); }catch{}

      if(dragging){
        saveMagPos(key, el);
      }

      dragging = false;
      pointerId = null;
      start = null;
      headerEl.classList.remove("dragging");
      e.preventDefault();
    };

    headerEl.addEventListener("pointerup", end);
    headerEl.addEventListener("pointercancel", end);
  }

  function updateMagUI(){
    magZoomVal.textContent = `${Number(magZoom.value).toFixed(1)}x`;
    magSizeVal.textContent = `${Number(magSize.value)}px`;

    const on = magOn.checked;
    const hasVideo = !!video.videoWidth && !!video.videoHeight && !!stageW && !!stageH;
    const visible = on && hasVideo;

    magA.style.display = visible ? "" : "none";
    magB.style.display = visible ? "" : "none";
    focusRectA.style.display = visible ? "" : "none";
    focusRectB.style.display = visible ? "" : "none";

    const win = Number(magSize.value);
    magA.style.width = `${win}px`;
    magB.style.width = `${win}px`;

    const dpr = window.devicePixelRatio || 1;
    const px = Math.max(64, Math.round(win * dpr));
    magCanvasA.width = px; magCanvasA.height = px;
    magCanvasB.width = px; magCanvasB.height = px;

    if(visible){
      clampMagToViewport(magA);
      clampMagToViewport(magB);
    }

    updateFocusRects();
  }

  function drawMagnifierOne(which, f, magEl, canvas, ctx, infoEl){
    if(!magOn.checked) return;
    if(magEl.style.display === "none") return;
    if(!video.videoWidth || !video.videoHeight || !stageW || !stageH) return;

    const vpos = stageXYToVideoXY(f.x, f.y);
    if(!vpos) return;

    const mz = Number(magZoom.value);
    const outW = canvas.width;
    const outH = canvas.height;

    const cropW = (f.size * vpos.sx) / mz;
    const cropH = (f.size * vpos.sy) / mz;

    const sx = clamp(vpos.x - cropW/2, 0, video.videoWidth - cropW);
    const sy = clamp(vpos.y - cropH/2, 0, video.videoHeight - cropH);

    ctx.clearRect(0,0,outW,outH);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, outW, outH);

    ctx.strokeStyle = (which === "A") ? "rgba(58,123,213,.95)" : "rgba(255,107,107,.95)";
    ctx.lineWidth = Math.max(2, Math.round(outW * 0.008));
    ctx.strokeRect(6,6,outW-12,outH-12);

    ctx.strokeStyle = "rgba(232,238,247,.85)";
    ctx.lineWidth = Math.max(1, Math.round(outW * 0.005));
    ctx.beginPath();
    ctx.moveTo(outW/2, 10); ctx.lineTo(outW/2, outH-10);
    ctx.moveTo(10, outH/2); ctx.lineTo(outW-10, outH/2);
    ctx.stroke();

    infoEl.textContent = `mt ${fmtTime(curMediaTime)} / x${mz.toFixed(2)}`;
  }

  function drawMagnifiers(){
    if(!magOn.checked) return;
    drawMagnifierOne("A", focusA, magA, magCanvasA, magCtxA, magInfoA);
    drawMagnifierOne("B", focusB, magB, magCanvasB, magCtxB, magInfoB);
  }

  // ---- Events
  zoom.addEventListener("input", () => updateStageTransform());
  rotL.addEventListener("click", () => { rotation = (rotation - 90) % 360; updateStageTransform(); });
  rotR.addEventListener("click", () => { rotation = (rotation + 90) % 360; updateStageTransform(); });

  magOn.addEventListener("change", () => updateMagUI());
  magZoom.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });
  magSize.addEventListener("input", () => { updateMagUI(); drawMagnifiers(); });

  pickA.addEventListener("click", () => { activePick = "A"; updateActivePickUI(); pickHint.textContent = "→ 動画をタップ/ドラッグで A を移動"; });
  pickB.addEventListener("click", () => { activePick = "B"; updateActivePickUI(); pickHint.textContent = "→ 動画をタップ/ドラッグで B を移動"; });

  magMarkInput.addEventListener("click", () => markInput.click());
  magMarkOutput.addEventListener("click", () => markOutput.click());

  toStart.addEventListener("click", async () => { stopStepPlay(); await seekTo(0); });
  toEnd.addEventListener("click", async () => { stopStepPlay(); await seekTo(video.duration || 0); });

  stepBack.addEventListener("click", async () => { await stepAdjacent(-1); });
  stepFwd.addEventListener("click", async () => { await stepAdjacent(+1); });

  pauseBtn.addEventListener("click", () => { stopStepPlay(); video.pause(); });

  stepPlay.addEventListener("click", () => {
    if(stepTimer){
      stopStepPlay();
      return;
    }
    stepPlay.textContent = "⏱ 1秒に1コマ（ON）";
    video.pause();
    stepTimer = setInterval(() => stepAdjacent(+1, true), 1000);
  });

  seek.addEventListener("input", async () => {
    stopStepPlay();
    const t = Number(seek.value);
    await seekTo(t);
  });

  markInput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    inputMark = { t: curMediaTime, at: new Date(), kind:"input" };
    pushMarker("input", inputMark.t);
    updateCurrentSummary();
  });

  markOutput.addEventListener("click", () => {
    if(curMediaTime == null) return;
    outputMark = { t: curMediaTime, at: new Date(), kind:"output" };
    pushMarker("output", outputMark.t);

    if(inputMark){
      pushMeasure(inputMark.t, outputMark.t);
    }
    updateCurrentSummary();
  });

  clearCurrent.addEventListener("click", () => {
    inputMark = null;
    outputMark = null;
    updateCurrentSummary();
  });

  prevMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel <= 0) ? (markers.length - 1) : (markerSel - 1);
    await seekTo(markers[markerSel].t);
  });

  nextMarker.addEventListener("click", async () => {
    stopStepPlay();
    if(!markers.length) return;
    markerSel = (markerSel >= markers.length - 1) ? 0 : (markerSel + 1);
    await seekTo(markers[markerSel].t);
  });

  copyCurrent.addEventListener("click", async () => {
    const inT = inputMark ? inputMark.t : null;
    const outT = outputMark ? outputMark.t : null;
    const deltaMs = (inT != null && outT != null) ? ((outT - inT) * 1000) : null;
    const text =
`inputTime(mediaTime): ${inT != null ? fmtTime(inT) : "—"}
displayTime(mediaTime): ${outT != null ? fmtTime(outT) : "—"}
deltaMs: ${deltaMs != null ? deltaMs.toFixed(2) : "—"} ms`;
    try{
      await navigator.clipboard.writeText(text);
    }catch{
      alert(text);
    }
  });

  resetVfr.addEventListener("click", () => {
    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    updateVfrDisp();
  });

  // File load
  file.addEventListener("change", async () => {
    stopStepPlay();

    inputMark = null;
    outputMark = null;
    markers = [];
    measures = [];
    markerSel = -1;
    vfr = { min: Infinity, max: -Infinity, sum: 0, n: 0 };
    renderMarkers();
    renderMeasures();
    updateVfrDisp();
    updateCurrentSummary();

    const f = file.files?.[0];
    if(!f) return;

    if(video.src && video.src.startsWith("blob:")){
      try { URL.revokeObjectURL(video.src); } catch {}
    }

    const url = URL.createObjectURL(f);

    video.src = url;
    video.preload = "auto";
    video.muted = true;
    video.playsInline = true;
    video.load();

    try{
      await video.play();
      video.pause();
      video.currentTime = 0;
    }catch(e){
      console.log("prime play failed:", e);
    }
  });

  video.addEventListener("error", () => {
    const err = video.error;
    alert(`動画の読み込みに失敗しました（error code: ${err?.code ?? "?"}）\n別形式（H.264 mp4等）に変換すると再生できることがあります。`);
  });

  video.addEventListener("loadedmetadata", () => {
    enableControls(true);
    updateSeekMax();

    const ro = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        updateStageSize();

        if((focusA.x === 0 && focusA.y === 0) && (focusB.x === 0 && focusB.y === 0)){
          focusA.x = stageW * 0.35;
          focusA.y = stageH * 0.55;
          focusB.x = stageW * 0.65;
          focusB.y = stageH * 0.45;
        }
        updateMagUI();
        // 表示された後にデフォルト位置or復元（rectが取れる状態で）
        ensureDefaultMagPos();
        drawMagnifiers();
      });
    });
    ro.observe(content);

    updateStageSize();
    updateStageTransform();
    updateMagUI();

    // drag init
    makeMagDraggable(magA, magHeaderA, "magA_pos");
    makeMagDraggable(magB, magHeaderB, "magB_pos");

    // show + default/restore
    ensureDefaultMagPos();

    startRvfc();
  });

  window.addEventListener("resize", () => {
    if(magA.style.display !== "none"){
      clampMagToViewport(magA);
      clampMagToViewport(magB);
    }
  });

  // Stage interaction (focus move)
  let draggingFocus = false;

  stage.addEventListener("pointerdown", (e) => {
    if(!stageW || !stageH) return;
    draggingFocus = true;
    stage.setPointerCapture(e.pointerId);

    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
    e.preventDefault();
  });

  stage.addEventListener("pointermove", (e) => {
    if(!draggingFocus || !stageW || !stageH) return;
    const p = clientToStageXY(e.clientX, e.clientY);
    const f = (activePick === "A") ? focusA : focusB;
    f.x = clamp(p.x, 0, stageW);
    f.y = clamp(p.y, 0, stageH);
    updateFocusRects();
    drawMagnifiers();
    e.preventDefault();
  });

  stage.addEventListener("pointerup", () => { draggingFocus = false; });
  stage.addEventListener("pointercancel", () => { draggingFocus = false; });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.target && ["INPUT","SELECT","TEXTAREA"].includes(e.target.tagName)) return;

    if(e.code === "ArrowLeft"){ e.preventDefault(); stepAdjacent(-1); }
    if(e.code === "ArrowRight"){ e.preventDefault(); stepAdjacent(+1); }

    if(e.code === "KeyI"){ e.preventDefault(); markInput.click(); }
    if(e.code === "KeyO"){ e.preventDefault(); markOutput.click(); }

    if(e.code === "KeyJ"){ e.preventDefault(); prevMarker.click(); }
    if(e.code === "KeyK"){ e.preventDefault(); nextMarker.click(); }

    if(e.code === "Space"){ e.preventDefault(); stepPlay.click(); }
  });

  // Init
  enableControls(false);
  updateStageTransform();
  updateMagUI();
  updateVfrDisp();
  updateCurrentSummary();
  renderMarkers();
  renderMeasures();
})();
</script>
</body>
</html>
